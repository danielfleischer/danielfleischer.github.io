<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://danielfleischer.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://danielfleischer.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-09-07T17:40:12+00:00</updated><id>https://danielfleischer.github.io/feed.xml</id><title type="html">blank</title><subtitle>Personal website for Daniel Fleischer. </subtitle><entry><title type="html">Breaking Language Barriers in Mathematical AI: Introducing Hebrew Math Tutor</title><link href="https://danielfleischer.github.io/blog/2025/breaking-language-barriers-in-mathematical-ai-introducing-hebrew-math-tutor/" rel="alternate" type="text/html" title="Breaking Language Barriers in Mathematical AI: Introducing Hebrew Math Tutor"/><published>2025-09-07T00:00:00+00:00</published><updated>2025-09-07T00:00:00+00:00</updated><id>https://danielfleischer.github.io/blog/2025/breaking-language-barriers-in-mathematical-ai-introducing-hebrew-math-tutor</id><content type="html" xml:base="https://danielfleischer.github.io/blog/2025/breaking-language-barriers-in-mathematical-ai-introducing-hebrew-math-tutor/"><![CDATA[<p>Hebrew Math Tutor (Intel/hebrew-math-tutor-v1) brings advanced mathematical problem-solving capabilities directly to Hebrew speakers, providing detailed step-by-step reasoning entirely in Hebrew without sacrificing the computational accuracy that makes these models valuable for education.Advanced mathematical AI models like those trained on competition mathematics datasets have shown remarkable problem-solving abilities. However, they primarily operate in English, creating barriers for non-English speaking educational communities. Hebrew speakers, in particular, have faced challenges accessing these powerful educational tools in their native language.Simply translating outputs isn‚Äôt enough‚Äîeffective mathematical tutoring requires natural language flow, culturally appropriate explanations, and seamless integration of Hebrew text with mathematical notation. This requires a more sophisticated approach.Hebrew Math Tutor addresses these challenges through targeted fine-tuning of Qwen3-4B-Thinking-2507, a powerful 4-billion parameter mathematical reasoning model. Our approach focuses on three key principles:The model provides complete mathematical explanations in natural Hebrew while preserving mathematical notation and formal expressions. It understands Hebrew mathematical terminology and can explain complex concepts using appropriate pedagogical language.By carefully fine-tuning rather than training from scratch, we maintain the model‚Äôs core mathematical reasoning capabilities while adapting its communication style to Hebrew.At ~4 billion parameters, the model strikes an optimal balance between capability and computational efficiency, making it practical for educational applications and research prototyping.Creating an effective Hebrew math model required more than simple translation. Our methodology involved:We selected ~10,000 high-quality problems from the OpenMathReasoning dataset, translating questions and answers to Hebrew while preserving the original reasoning chains and mathematical notation.We fine-tuned the model over 3 epochs with optimized parameters (learning rate 5e-6, 0.1 warmup, cosine scheduling) to adapt the output language while maintaining the underlying reasoning capabilities.The model‚Äôs internal <think>...</think> reasoning blocks remain in English, as these represent core computational processes that would require more extensive training to modify.We evaluated Hebrew Math Tutor against its base model on three challenging mathematical benchmarks: MATH500 (curriculum problems), AIME24, and AIME25 (competition mathematics). The results demonstrate significant improvements in Hebrew language output while maintaining strong technical performance.üöÄ Dramatic Hebrew Language Gains: Hebrew answer production jumped from 35-75% to 95-100% across all benchmarks‚Äîa transformative improvement for Hebrew-speaking users.üìà Consistent Accuracy Improvements: Notable gains in pass@16 scores on Hebrew evaluations, showing the model doesn‚Äôt just translate but actually improves problem-solving in Hebrew contexts.üîÑ Preserved Core Capabilities: Maintained competitive English performance, demonstrating that Hebrew specialization didn‚Äôt compromise the model‚Äôs fundamental mathematical abilities.‚öñÔ∏è Nuanced Majority Vote Results: While performance improved on MATH500 and remained stable on AIME24, there‚Äôs an interesting decrease in maj@16 on AIME25 that provides insights for future training approaches.Hebrew Math Tutor opens new possibilities across multiple domains:Hebrew Math Tutor integrates seamlessly with the Transformers ecosystem:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Hebrew Math Tutor in action: A Streamlit interface showing detailed step-by-step reasoning in Hebrew. The expandable reasoning sections allow users to dive deep into the mathematical process or focus on final answers. While Hebrew Math Tutor represents significant progress, responsible deployment requires careful consideration:The model works best as an educational aid rather than a replacement for qualified instruction. We recommend implementing human oversight, providing clear disclaimers about AI-generated content, and ensuring compliance with relevant privacy regulations in educational applications.Hebrew Math Tutor demonstrates that language barriers in AI can be effectively addressed through thoughtful fine-tuning approaches. This work represents more than just a Hebrew mathematical model‚Äîit's a proof of concept for making advanced AI capabilities truly accessible across linguistic communities.The techniques developed here can be adapted for other languages, creating a pathway toward more inclusive mathematical AI tools. As we continue to refine these approaches, we're moving closer to a future where language is no longer a barrier to accessing the most advanced educational technologies.Hebrew Math Tutor is available now under the Apache-2.0 license. We encourage the community to:üöÄ Start exploring Hebrew Math Tutor today and experience mathematical AI that truly speaks your language.Built with gratitude upon the foundational work of Qwen3-4B-Thinking-2507 and the OpenMathReasoning dataset.¬∑
				Sign up or
				log in to comment
</code></pre></div></div>]]></content><author><name></name></author><summary type="html"><![CDATA[A Blog post by Daniel Fleischer on Hugging Face]]></summary></entry><entry><title type="html">Jujutsu Impressions</title><link href="https://danielfleischer.github.io/blog/2025/jj/" rel="alternate" type="text/html" title="Jujutsu Impressions"/><published>2025-08-29T00:00:00+00:00</published><updated>2025-08-29T00:00:00+00:00</updated><id>https://danielfleischer.github.io/blog/2025/jj</id><content type="html" xml:base="https://danielfleischer.github.io/blog/2025/jj/"><![CDATA[<h4 id="tldr">TL;DR</h4> <ul> <li>JJ does things differently from Git, but it‚Äôs compatible enough to try. The core unit is the persistent <strong>change</strong>, which evolves through snapshots.</li> <li>Actions are logged as operations, enabling undo and restore to any point in time.</li> <li>No Git-style branches. Changes have persistent IDs, and you use bookmarks for Git-forge workflows.</li> <li>You can colocate <code class="language-plaintext highlighter-rouge">jj</code> with an existing Git repo, keeping your Git workflow intact while <code class="language-plaintext highlighter-rouge">jj</code> handles history.</li> <li>Curious? Follow the tutorial or experiment on a current repo to see the difference firsthand.</li> </ul> <hr/> <p>In this post I‚Äôll share some insights about using the <a href="https://jj-vcs.github.io/jj/latest/">Jujutsu version control system</a>, which I‚Äôll call <code class="language-plaintext highlighter-rouge">jj</code> for the rest of the post.</p> <p><code class="language-plaintext highlighter-rouge">jj</code> is a version control system, currently built on top of git, using its building blocks. However, it‚Äôs not just a new porcelain; it defines new abstractions and data structures of its own.</p> <h4 id="concept-the-change-as-the-atomic-unit">Concept: The Change as the Atomic Unit</h4> <p>The most important concept is the <strong>change</strong>. The <strong>change</strong> defines an atomic unit of, well, change. Its analog is the git commit. But in <code class="language-plaintext highlighter-rouge">jj</code>, a change can develop in time. Technically, it‚Äôs a git commit that keeps getting amended, the difference being that the <strong>change</strong> keeps its identity via a persistent ID and a description field. A <strong>change</strong> updates whenever <code class="language-plaintext highlighter-rouge">jj</code> takes a snapshot of the repo‚Äîevery time you call <code class="language-plaintext highlighter-rouge">jj</code>. If you think about it, <code class="language-plaintext highlighter-rouge">jj</code> can‚Äôt lose work, as it always starts by taking a snapshot, even for informative commands like <code class="language-plaintext highlighter-rouge">jj log</code>.</p> <p>Thus the <strong>change</strong> represents an amended commit, the ‚Äúlast‚Äù change. However, <code class="language-plaintext highlighter-rouge">jj</code> lets you inspect the internal, previous commits inside the <strong>change</strong>, by calling <code class="language-plaintext highlighter-rouge">jj evolog</code>. These internal commits are not synced to git forges and are not automatically garbage collected, like git amended commits are.</p> <p>When we are done with a <strong>change</strong>, we can give it a description (which we can do at any time using <code class="language-plaintext highlighter-rouge">jj description</code>) and create an empty <strong>change</strong> on top of it, ready to receive new modifications. We do that using <code class="language-plaintext highlighter-rouge">jj commit</code>.</p> <p>For example, when you initialize a repo, the initial current <strong>change</strong> is empty. You add files, edit them. When you are ready, you give this change a name via <code class="language-plaintext highlighter-rouge">jj description</code> and then start a new change via <code class="language-plaintext highlighter-rouge">jj new</code>, or do both at the same time via <code class="language-plaintext highlighter-rouge">jj commit</code>.</p> <h4 id="graph-branches-and-bookmarks">Graph, Branches, and Bookmarks</h4> <p>Moving around (<code class="language-plaintext highlighter-rouge">git checkout</code>) is done with <code class="language-plaintext highlighter-rouge">jj edit</code>. But we need to be careful, as any edit we make after the jump will get snapshots (‚Äúamended‚Äù) on top of the current <strong>change</strong>, modifying it. If you want to jump in to do some work, it‚Äôs better to use <code class="language-plaintext highlighter-rouge">jj new</code>.</p> <p>You might see the claim there are no branches in <code class="language-plaintext highlighter-rouge">jj</code>. There aren‚Äôt branches in the usual git sense. In <code class="language-plaintext highlighter-rouge">jj</code>s graph there are ‚Äúbranches‚Äù, but they don‚Äôt need names. The persistent <strong>change</strong> IDs serve as feature names and jump addresses (using <code class="language-plaintext highlighter-rouge">edit</code> or <code class="language-plaintext highlighter-rouge">new</code>). Nevertheless, branch names are introduced in <code class="language-plaintext highlighter-rouge">jj</code> in order to be compatible with git forges; they are called <strong>bookmarks</strong>, and they need to be moved explicitly across the <strong>changes</strong>.</p> <h4 id="logging-and-time-travel">Logging and Time Travel</h4> <p><code class="language-plaintext highlighter-rouge">jj</code> logs what‚Äôs happening using <strong>operations</strong>: these are the commands you enter and the current <em>change</em> you‚Äôre in, in addition to some metadata. The logs enable handy features like <code class="language-plaintext highlighter-rouge">jj undo</code> or the deeper <code class="language-plaintext highlighter-rouge">jj op restore</code> (restore to any point in time). For browsing the operation log, see <code class="language-plaintext highlighter-rouge">jj op log</code>.</p> <p>There is a <a href="https://jj-vcs.github.io/jj/latest/git-command-table/">comparison</a> table between <code class="language-plaintext highlighter-rouge">git</code> and <code class="language-plaintext highlighter-rouge">jj</code> commands, which could be useful but it‚Äôs important to not fixate on how <code class="language-plaintext highlighter-rouge">git</code> is doing things in order to be open to the new paradigm <code class="language-plaintext highlighter-rouge">jj</code> represents. However, some features seem to have been added in response to git users‚Äô needs or workflows, or perhaps <code class="language-plaintext highlighter-rouge">jj</code> developers rediscovered the same needs.</p> <h4 id="mixing-jj-with-git">Mixing JJ with Git</h4> <p>I chose one existing git project and converted it to a mixed usage of <code class="language-plaintext highlighter-rouge">jj</code> and <code class="language-plaintext highlighter-rouge">git</code>, using <code class="language-plaintext highlighter-rouge">jj git init --colocate</code>. It means <code class="language-plaintext highlighter-rouge">jj</code> initialize its presence in an existing repo and it will keep updating the <code class="language-plaintext highlighter-rouge">.git</code> folder with what‚Äôs happening, at a level compatible with git constructs; for example, the <strong>changes</strong> are saved as git commits, <code class="language-plaintext highlighter-rouge">jj git fetch</code> is fetching from git forges into <code class="language-plaintext highlighter-rouge">.git/</code>, etc. I haven‚Äôt used rebasing, squashing or other history-changing operations so I can‚Äôt comment on how easy they are to use, maybe next time.</p> <p>If you found it interesting, give it a try. There‚Äôs the <a href="https://jj-vcs.github.io/jj/latest/tutorial/">tutorial</a>, or you can run it on an existing git repo.</p>]]></content><author><name></name></author><category term="software"/><category term="git"/><summary type="html"><![CDATA[My first impression of using the Jujutsu version control system.]]></summary></entry><entry><title type="html">Built an MCP server for LLMs to search email from terminal | Daniel Fleischer posted on the topic | LinkedIn</title><link href="https://danielfleischer.github.io/blog/2025/built-an-mcp-server-for-llms-to-search-email-from-terminal-daniel-fleischer-posted-on-the-topic-linkedin/" rel="alternate" type="text/html" title="Built an MCP server for LLMs to search email from terminal | Daniel Fleischer posted on the topic | LinkedIn"/><published>2025-06-23T00:00:00+00:00</published><updated>2025-06-23T00:00:00+00:00</updated><id>https://danielfleischer.github.io/blog/2025/built-an-mcp-server-for-llms-to-search-email-from-terminal--daniel-fleischer-posted-on-the-topic--linkedin</id><content type="html" xml:base="https://danielfleischer.github.io/blog/2025/built-an-mcp-server-for-llms-to-search-email-from-terminal-daniel-fleischer-posted-on-the-topic-linkedin/"><![CDATA[<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>          Agree &amp; Join LinkedIn
        
  By clicking Continue to join or sign in, you agree to LinkedIn‚Äôs User Agreement, Privacy Policy, and Cookie Policy.

            AI Research Engineer @ Intel Labs
        üì¨ I built an MCP server that lets LLMs search my email from the terminal
</code></pre></div></div> <p>The server connects Claude to email search via the mu CLI tool. Now I just ask it things like: ‚ÄúFind emails with PDF attachments from last April‚Äù ‚ö°</p> <p>üõ† No custom frontend. No heavy framework. Just a CLI tool made smarter.</p> <p>üí° I learned that MCP servers are basically API translators ‚Äî they take complex developer SDKs and flatten them into simple function calls that LLMs can actually use.</p> <p>üéØ The bigger picture: This pattern can breathe new life into existing CLI tools and services. Complex APIs ‚Üí Simple, declarative functions ‚Üí Natural language queries.</p> <p>This isn‚Äôt a product ‚Äî just an experiment in stitching new capabilities into existing workflows. Code here: https://lnkd.in/eT2fJBSv</p> <p>mu email indexer and searcher: https://github.com/djcb/mu</p> <p>#MCP #LLM #EmailSearch #OpenSource #AI</p> <p>What existing tools would you want to make LLM-friendly? ü§î To view or add a comment, sign in</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            Cloud, DevOps, and Full-stack professional
        Tired of manually writing function-calling definitions for every single API endpoint you want your LLM to use?
</code></pre></div></div> <p>I built Conduit to solve this. It‚Äôs an open-source tool that automatically exposes any existing GraphQL API to an LLM as a ready-to-use toolset.</p> <p>Conduit leverages GraphQL‚Äôs strong typing and introspection capabilities to dynamically generate a tool manifest via the Model Context Protocol (MCP). An AI agent can connect to Conduit, understand the available tools (your GraphQL queries/mutations), and execute them.</p> <p>This automates the most tedious part of giving AI agents new capabilities, allowing you to focus on the agent‚Äôs logic instead of the boilerplate. The entire project is written in TypeScript.</p> <p>If you‚Äôre building with LLMs and need to connect to GraphQL data sources, this might save you a lot of time.</p> <p>Contributions and feedback are welcome! GitHub: https://lnkd.in/gr38VWv3 #LLM #FunctionCalling #AIAgents #MachineLearning #GraphQL #API #TypeScript #NodeJS #MLOps #AIengineering To view or add a comment, sign in</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            Founder of Yearbook  | Flutter Application developer | Content Creator
        Are You Tired of Structuring AI Prompts 
</code></pre></div></div> <p>Microsoft got your back with newly launched POML (Prompt Orchestration Markup Language) Language , Its like html and based on xml and helps you structure your ptompts easily so you Can get the desired Output for the tokens spent.</p> <p>Here‚Äôs How to Use it , 1) Install POML by running pip install poml or npm install poml js ‚Äì for node js 2) Install VS code extension by searching ‚Äòpoml‚Äô 3) Crete a POML file and write your Promot 4) Test it with your preferred AI Model</p> <p>Thats it gor today follow me on linkedin For Business and Tech Insights.</p> <p>#poml #html #ai #prompt #promptengineering #future #microsoft To view or add a comment, sign in</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            SDE at Anonimo | EX - HeyCoach, GFG | 3‚≠ê@Codechef(max 1615) | Pupil@codeforces(max 1242) | Web Development, React| Node Js| KLU'25
        After MCP, A2A, &amp; AG-UI, there's another Agent protocol that is  ACP (Agent Communication Protocol) and the best Part is it is fully Open Source
</code></pre></div></div> <p>But before we dive into ACP, let‚Äôs quickly revisit the earlier 3 üëá</p> <ol> <li> <p>MCP (Model Context Protocol) Problem before MCP: Every new tool = custom integration code With MCP: One universal adapter for APIs, tools, files. -&gt; Think of it as the USB-C for agents ‚Äî plug anything in, it just works.</p> </li> <li> <p>A2A (Agent-to-Agent) Problem before A2A: Agents couldn‚Äôt hand off tasks cleanly ‚Üí worked in silos. With A2A: Agents collaborate like a team with walkie-talkies¬† -&gt; Funny Part is: Google made this A2A protocol just to show they‚Äôre updated in the market, like saying yes, after MCP, we‚Äôve launched something new.</p> </li> <li> <p>AG-UI (Agent ‚Üí UI) Problem before AG-UI: Each agent gave random outputs ‚Üí frontend devs had to write messy glue code. With AG-UI: Agents return standard UI components (forms, tables, charts). -&gt; Basically ‚Üí one design system for AI outputs</p> </li> <li> <p>ACP (Agent Communication Protocol) ‚Äî by IBM ACP is like a traffic control system for coordinating agents at scale. It‚Äôs open source, RESTful, and even ships with a Python SDK!</p> </li> </ol> <p>Key ACP Features (solution-architect friendly):</p> <ol> <li>Supports both stateful and stateless agents</li> <li>Uses JSON-RPC for structured, reliable comms</li> <li>Handles natural language interfaces (so humans ‚Üî agents is smooth)</li> <li>Offers real-time streaming (great for live dashboards, chat)</li> <li>Flexible deployment + legacy integration (you can fit it in old infra too) -&gt; ¬†In short: ACP = the dispatcher + rulebook for multiple agents working together.</li> </ol> <p>#AI #ArtificialIntelligence #AIAgents #AgenticAI #MultiAgentSystems #AICommunity #OpenSourceAI #AIStandards To view or add a comment, sign in</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            I help labs reduce costs and improve the quality of diagnostics by the means of AI
        New release of AgentCraft (it's like Cursor, but for n8n). This Chrome extension integrates directly into the n8n interface and helps  build, configure, and debug workflows up to 10x faster with AI assistance.
</code></pre></div></div> <p>Key Features: üîé Search &amp; insert ready-to-use workflows üí¨ MCP-powered chat with n8n documentation access ‚ö° One-click workflow generation from natural language üîß AI-powered node configuration üåê Generate and import CURL into HTTP node üõ†Ô∏è AI Fixer for errors in workflows &amp; ‚ö°Generate JavaScript code üìë JSON auto-fixing ü§ñ Prompt generator for AI assistants üéõÔ∏è Trigger emulation with test data üóíÔ∏è Auto-generated sticky notes üíæ Autosave &amp; backup history</p> <p>Link - https://lnkd.in/ej-JkZKs To view or add a comment, sign in</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            On Prem GenAI Digital Transformation for BFSI Sector
        We tested Microsoft‚Äôs new POML (Prompt Orchestration Markup Language) at Ekkel AI on a few internal workflows to see how it performs in practice.
</code></pre></div></div> <p>Where it worked well: - Multi-step workflows: Breaking prompts into <role>, <task>, and <example> tags made our multi-agent setups easier to manage. - Reusable templates: We could reuse the same prompt structure across different projects just by swapping in variables and data sources. - Context embedding: Adding documents and tables directly into the prompt through POML tags improved accuracy for context-heavy tasks. - Version control: The structured format made it easier to track prompt changes in Git, which is harder with plain text prompts.</example></task></role></p> <p>Where it could improve: - Tooling maturity: The VS Code extension works well, but more integration with prompt testing platforms would help. - Language support: Official .NET SDK support would be valuable for certain enterprise stacks.</p> <p>Overall, POML is promising, especially for large-scale, repeatable prompt workflows. For smaller or ad-hoc tasks, plain prompts are still quicker. To view or add a comment, sign in</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            Senior Data scientist, 5+ years, CV, NLP, Classic ML, Gen AI
        MCP is getting serious: first benchmark for real tool‚Äëuse
</code></pre></div></div> <p>The Model Context Protocol (MCP) launched about nine months ago (Nov‚ÄØ2024) and has been spreading fast across major platforms. It‚Äôs the ‚Äúplug‚Äù that lets models talk to real tools and data.</p> <p>Now there‚Äôs a dedicated benchmark: MCP‚ÄëUniverse (Salesforce AI Research). It tests models against real MCP servers across 6 domains - Location navigation, Repository management, Financial analysis, 3D design, Browser automation, Web searching - using execution‚Äëbased checks on 231 tasks.</p> <p>A detail I like: tasks are multi‚Äëstep. Runs typically take ~6-8 tool calls, which puts pressure on long‚Äëcontext handling and planning. In early results, GPT‚Äë5 tops the overall leaderboard and leads in most domains (with Grok‚Äë4 slightly ahead in browser automation).</p> <p>Bottom line: MCP is maturing fast ‚Äî and now it‚Äôs measurable. What gets measured gets improved, so expect rapid progress in tool use, planning, and context management next.</p> <p>Link: https://lnkd.in/g4KcpJFW To view or add a comment, sign in</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            Babysitting AI agents
        Claude Code is a general purpose agent disguised as a coding agent.
</code></pre></div></div> <p>It searches the web. It integrates with tools through MCP. It executes multi-step workflows. All the basics you‚Äôd expect.</p> <p>But it‚Äôs not just a general-purpose agent. It‚Äôs a code-first agent, not just an agent that helps you code, but one that codes to expand what it can do.</p> <p>Having bash access, Claude Code controls your operating system directly. It can install packages, script CLI tools together, and automate anything you can do in a terminal. Combined with file system access, it can search, read, and modify files across your computer. Your entire system becomes its workspace, if you allow it.</p> <p>More importantly, it writes code. When other agents hit a wall because no tool exists for a task, Claude Code can build one. It can write parsers for unusual file formats. It can reverse-engineer undocumented APIs and build clients. It can create data processing pipelines, automation scripts, whatever the task demands. The tool doesn‚Äôt exist until it needs to exist.</p> <p>It‚Äôs also composable, a capability unique to CLI-based agents. Claude Code can spawn specialized versions of itself as subagents, each with full tool access. Give it web search and file creation, and it can replicate features like ‚ÄúDeep Research‚Äù. What others hard-code, it builds from primitives.</p> <p>Code-first agents don‚Äôt just use tools. They script them together, build new ones, and orchestrate multiple instances of themselves to create capabilities that didn‚Äôt exist before. Other agents work within their constraints. Claude Code can read its own source code, analyze how it works, and modify its configuration files to change its behavior.</p> <p>#anthropic #agent #claudecode #llm #ai To view or add a comment, sign in</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            3 followers
        Here we are with the post about Request validation and validation in general. As it is required now to validate the tool CreateReservation query and API request to create reservation, I decided to use as much Laravel features as possible. Just write validation in the laravel v12 documentation üìú,¬†and the guidelines are pretty good I could tell you.
</code></pre></div></div> <p>The only thing I haven‚Äôt spotted, before AI actually introduced me to it is make:rule artisan command, which is just a lifesaver if you know what I mean. The code looks much cleaner when all the additional rules lies outside of the StoreRequest. Even with AI, human beings are necessary to build up the rules, validation, and think ahead. So, with the custom validation within the policies of #EasyBookr it was necessary to inject several important rules:</p> <p>üï£15 minutes rule: I strongly believe that it makes sense to limit people with the timing divided by 15, meaning that you won‚Äôt be able to create reservation that is less then 15 minutes long. It does not make any sense. Also that will keep system cleaner, customers less confused and easier for everyone to track the time correctly.</p> <p>üìÜ¬†Dates validation: Fixed rate type cannot have end date but only start date because it is fixed, so only one date is necessary to book the time correctly.</p> <p>üìÖ¬†Employee schedule rule: Not only the correct date but also time should be correctly picked, since we all have our own working hours. That should also be included into account.</p> <p>ü§î¬†Have I included all the rules into account? Let‚Äôs see. Good to start on. I won‚Äôt introduce all the rules here, of course, some basic ones won‚Äôt be included into the post, but are included into the project to prevent security breakdowns. To view or add a comment, sign in</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            Magento Developer at Scandesign Media A/S
        Validation rules. Are they widely used? I got to know them only when I reached the API flow. However, they may be more commonly used without a package, such as Filament? Don't know. I got to know it only because of AI Tools and API scope, but not on the frontend. 
            3 followers
        Here we are with the post about Request validation and validation in general. As it is required now to validate the tool CreateReservation query and API request to create reservation, I decided to use as much Laravel features as possible. Just write validation in the laravel v12 documentation üìú,¬†and the guidelines are pretty good I could tell you.
</code></pre></div></div> <p>The only thing I haven‚Äôt spotted, before AI actually introduced me to it is make:rule artisan command, which is just a lifesaver if you know what I mean. The code looks much cleaner when all the additional rules lies outside of the StoreRequest. Even with AI, human beings are necessary to build up the rules, validation, and think ahead. So, with the custom validation within the policies of #EasyBookr it was necessary to inject several important rules:</p> <p>üï£15 minutes rule: I strongly believe that it makes sense to limit people with the timing divided by 15, meaning that you won‚Äôt be able to create reservation that is less then 15 minutes long. It does not make any sense. Also that will keep system cleaner, customers less confused and easier for everyone to track the time correctly.</p> <p>üìÜ¬†Dates validation: Fixed rate type cannot have end date but only start date because it is fixed, so only one date is necessary to book the time correctly.</p> <p>üìÖ¬†Employee schedule rule: Not only the correct date but also time should be correctly picked, since we all have our own working hours. That should also be included into account.</p> <p>ü§î¬†Have I included all the rules into account? Let‚Äôs see. Good to start on. I won‚Äôt introduce all the rules here, of course, some basic ones won‚Äôt be included into the post, but are included into the project to prevent security breakdowns. To view or add a comment, sign in</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            Leading Developer Advocacy @ CrewAI ‚Ä¢ Automating business workflows with AI
        i‚Äôve wired up a bunch of MCP servers but not for semantic code search.
</code></pre></div></div> <p>i decided to try out the new Claude Context MCP plugin by Zilliz using Claude Code and I found it quite interesting and I think you will as well.</p> <p>so what is it? it‚Äôs a powerful semantic code search tool that gives your AI coding assistants deep understanding of your entire codebase. Instead of grep or basic keyword search, you can ask natural language questions about your codebase and get actual relevant code back.</p> <p>the setup is interesting (mermaid diagram in comments), it takes your code: ‚Ä¢ parses it through AST (Abstract Syntax Tree)[1] (chunk by structure) ‚Ä¢ chunks it intelligently ‚Ä¢ embeds the code using openai/voyage/ollama/gemini¬† ‚Ä¢ stores everything in Milvus, created by Zilliz vector db which is well known for being a beast in handling large-scale vector search across billions of embeddings</p> <p>to top it all off, it uses one of my favorite data structures, Merkle Trees. This allows it to perform incremental indexing on new changes and not the entire codebase.</p> <p>since it works through MCP, it integrates with claude code, cursor, vscode, and other MCP clients. I‚Äôve added the links to the repo + setup instructions in the chat.</p> <p>have you tried using this server yet?</p> <p>[1] an Abstract Syntax Tree (AST) is a hierarchical representation of your code‚Äôs structure. To view or add a comment, sign in</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        1,432 followers
      
                Create your free account or sign in to continue your search
              
          or
        
  By clicking Continue to join or sign in, you agree to LinkedIn‚Äôs User Agreement, Privacy Policy, and Cookie Policy.

            New to LinkedIn? Join now
          
                      or
                    
                New to LinkedIn? Join now
              
  By clicking Continue to join or sign in, you agree to LinkedIn‚Äôs User Agreement, Privacy Policy, and Cookie Policy.
</code></pre></div></div>]]></content><author><name></name></author><summary type="html"><![CDATA[üì¨ I built an MCP server that lets LLMs search my email from the terminal The server connects Claude to email search via the mu CLI tool. Now I just ask it things like: "Find emails with PDF attachments from last April" ‚ö° üõ† No custom frontend. No heavy framework. Just a CLI tool made smarter. üí° I learned that MCP servers are basically API translators ‚Äî they take complex developer SDKs and flatten them into simple function calls that LLMs can actually use. üéØ The bigger picture: This pattern can breathe new life into existing CLI tools and services. Complex APIs ‚Üí Simple, declarative functions ‚Üí Natural language queries. This isn‚Äôt a product ‚Äî just an experiment in stitching new capabilities into existing workflows. Code here: https://lnkd.in/eT2fJBSv mu email indexer and searcher: https://github.com/djcb/mu #MCP #LLM #EmailSearch #OpenSource #AI What existing tools would you want to make LLM-friendly? ü§î]]></summary></entry><entry><title type="html">Summarize Hacker News Posts with Haystack &amp;amp; OPEA | Haystack</title><link href="https://danielfleischer.github.io/blog/2025/summarize-hacker-news-posts-with-haystack-opea-haystack/" rel="alternate" type="text/html" title="Summarize Hacker News Posts with Haystack &amp;amp; OPEA | Haystack"/><published>2025-06-10T00:00:00+00:00</published><updated>2025-06-10T00:00:00+00:00</updated><id>https://danielfleischer.github.io/blog/2025/summarize-hacker-news-posts-with-haystack--opea--haystack</id><content type="html" xml:base="https://danielfleischer.github.io/blog/2025/summarize-hacker-news-posts-with-haystack-opea-haystack/"><![CDATA[<p>Build a RAG pipeline to fetch live Hacker News posts and summarize them with a local LLM endpointWelcome to this step-by-step tutorial where we‚Äôll build a simple Retrieval-Augmented Generation (RAG) pipeline using Haystack and OPEA. We‚Äôll fetch the newest Hacker News posts, feed them to a lightweight LLM endpoint (OPEAGenerator), and generate concise one-sentence summaries (based on this notebook). Let‚Äôs dive in! üéâIn modern GenAI applications, having a flexible, performant, and scalable platform is essential. OPEA (Open Platform for Enterprise AI) is an open, model-agnostic framework for building and operating composable GenAI solutions. It provides:In this demo, we‚Äôll use an OPEA LLM endpoint in a Haystack pipeline, giving you:In this tutorial, we‚Äôll build a simple RAG pipeline that fetches the newest Hacker News posts, sends them to a local OPEA endpoint running a Qwen/Qwen2.5-7B-Instruct demo model, and produces concise one-sentence summaries. Of course, you can replace our example model with any other OPEA-served model, making this pattern both lightweight for prototyping and powerful for real-world deployments. Let‚Äôs get started! üöÄMake sure you have:NOTE: As a reference, here is a Docker Compose recipe to get you started. OPEA LLM service can be configured to use a variety of model serving backends like TGI, vLLM, ollama, OVMS‚Ä¶ and offers validated runtime settings for good performance on various hardware‚Äôs including Intel Gaudi. In this example, it creates an OPEA LLM service with a TGI backend. See the documentation for LLM Generation. The code is based on OPEA LLM example and OPEA TGI example.To run, call LLM_MODEL_ID=Qwen/Qwen2.5-7B-Instruct docker compose up.We‚Äôll create a custom Haystack component, HackernewsNewestFetcher, that:We use the OPEAGenerator to call our LLM over HTTP. Here, we point to a local endpoint serving the Qwen/Qwen2.5-7B-Instruct model:Using PromptBuilder, we define a Jinja-style template that:We wire up the components in a Pipeline:Fetch and summarize the top 2 newest Hacker News posts:Beautiful, concise summaries in seconds! ‚ú®In this tutorial, we built a full RAG pipeline:Feel free to extend this setup with more advanced retrieval, caching, or different LLM backends. Happy coding! üõ†Ô∏èüî• Building products, technology and solutions for LLM-enabled applications.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Build a RAG pipeline to fetch live Hacker News posts and summarize them with a local LLM endpoint]]></summary></entry><entry><title type="html">◊î◊û◊ï◊ì◊ú ◊©◊ú◊õ◊ù ◊î◊ï◊ñ◊î? ◊õ◊ö ◊™◊ë◊†◊ï ◊ë◊¢◊¶◊û◊õ◊ù ◊û◊¢◊®◊õ◊™ RAG | ◊í◊ô◊ß◊ò◊ô◊ô◊ù</title><link href="https://danielfleischer.github.io/blog/2024/rag/" rel="alternate" type="text/html" title="◊î◊û◊ï◊ì◊ú ◊©◊ú◊õ◊ù ◊î◊ï◊ñ◊î? ◊õ◊ö ◊™◊ë◊†◊ï ◊ë◊¢◊¶◊û◊õ◊ù ◊û◊¢◊®◊õ◊™ RAG | ◊í◊ô◊ß◊ò◊ô◊ô◊ù"/><published>2024-12-01T00:00:00+00:00</published><updated>2024-12-01T00:00:00+00:00</updated><id>https://danielfleischer.github.io/blog/2024/-------rag--</id><content type="html" xml:base="https://danielfleischer.github.io/blog/2024/rag/"><![CDATA[<p>◊ó◊ô◊§◊ï◊©◊ô◊ù ◊ó◊û◊ô◊ù: ◊û◊¢◊®◊õ◊ï◊™ RAG ◊ô◊õ◊ï◊ú◊ï◊™ ◊ú◊§◊™◊ï◊® ◊ê◊™ ◊™◊ï◊§◊¢◊™ ◊î◊î◊ñ◊ô◊ï◊™ ◊©◊ú LLMs, ◊ê◊ë◊ú ◊õ◊ì◊ô ◊ú◊ë◊†◊ï◊™ ◊ê◊ó◊™ ◊ò◊ï◊ë◊î ◊™◊¶◊ò◊®◊õ◊ï ◊ú◊ß◊ë◊ú ◊î◊®◊ë◊î ◊î◊ó◊ú◊ò◊ï◊™ ◊ß◊®◊ô◊ò◊ô◊ï◊™ (◊ï◊ú◊ß◊ï◊ï◊™ ◊©◊™◊í◊ô◊¢◊ï ◊î◊õ◊ô ◊ß◊®◊ï◊ë ◊ú◊û◊ï◊©◊ú◊ù) ◊î◊ê◊™◊í◊® ◊î◊¢◊ô◊ß◊®◊ô ◊ë◊ë◊†◊ô◊ô◊™ ◊û◊¢◊®◊õ◊™ RAG ◊î◊ï◊ê ◊ú◊î◊í◊ô◊¢ ◊ú◊®◊û◊™ ◊ê◊ô◊õ◊ï◊™ ◊ï◊ì◊ô◊ï◊ß ◊û◊ß◊°◊ô◊û◊ú◊ô◊ô◊ù (◊¶◊ô◊ú◊ï◊ù: Dreamstime)◊û◊ê◊™ ◊ì◊†◊ô◊ê◊ú ◊§◊ú◊ô◊ô◊©◊®, ◊ó◊ï◊ß◊® AI ◊ë-Intel Labs◊û◊ï◊ì◊ú◊ô ◊©◊§◊î ◊í◊ì◊ï◊ú◊ô◊ù (LLMs) ◊û◊¶◊ô◊¢◊ô◊ù ◊§◊™◊®◊ï◊†◊ï◊™ ◊û◊™◊ß◊ì◊û◊ô◊ù ◊ú◊ê◊™◊í◊®◊ô ◊§◊ô◊™◊ï◊ó, ◊ê◊ö ◊ú◊¢◊™◊ô◊ù, ◊û◊î ◊ú◊¢◊©◊ï◊™, ◊î◊ù ◊©◊ï◊í◊ô◊ù. ◊î◊û◊ò◊®◊î ◊©◊ú ◊û◊¢◊®◊õ◊ï◊™ RAG ◊î◊ô◊ê ◊ú◊§◊™◊ï◊® ◊ê◊™ ◊î◊ë◊¢◊ô◊î ◊î◊ñ◊ê◊™, ◊ë◊ê◊û◊¶◊¢◊ï◊™ ◊í◊ô◊©◊î ◊ó◊ì◊©◊î ◊ú◊©◊ô◊§◊ï◊® ◊ì◊ô◊ï◊ß ◊ï◊ê◊û◊ô◊†◊ï◊™ ◊î◊û◊ï◊ì◊ú◊ô◊ù. ◊ê◊ô◊ö ◊î◊ü ◊¢◊ï◊©◊ï◊™ ◊ê◊™ ◊ñ◊î, ◊î◊ê◊ù ◊î◊î◊ô◊ô◊§ ◊û◊ï◊¶◊ì◊ß ◊ï◊õ◊ô◊¶◊ì ◊†◊ï◊õ◊ú ◊ú◊ë◊†◊ï◊™ ◊û◊¢◊®◊õ◊™ RAG ◊û◊©◊ú◊†◊ï? ◊õ◊ì◊ô ◊ú◊¢◊†◊ï◊™ ◊¢◊ú ◊î◊©◊ê◊ú◊ï◊™ ◊î◊ê◊ú◊î, ◊ë◊ì◊ß◊™◊ô ◊ê◊™ ◊î◊ê◊™◊í◊®◊ô◊ù ◊ë◊í◊ô◊©◊î ◊ñ◊ï ◊ê◊ú ◊û◊ï◊ú ◊î◊ô◊™◊®◊ï◊†◊ï◊™ ◊©◊î◊ô◊ê ◊û◊¶◊ô◊¢◊î ◊ë◊©◊ì◊®◊ï◊í ◊î◊ê◊ô◊†◊ò◊®◊ê◊ß◊¶◊ô◊î ◊©◊ú◊†◊ï ◊¢◊ù AI.◊ú◊§◊†◊ô ◊©◊†◊¶◊ú◊ï◊ú, ◊ë◊ï◊ê◊ï ◊†◊ì◊ë◊® ◊®◊í◊¢ ◊¢◊ú LLMs. ◊ú◊û◊¢◊©◊î, ◊û◊ì◊ï◊ë◊® ◊ë◊ô◊ô◊¶◊ï◊í ◊û◊™◊û◊ò◊ô ◊©◊ú ◊©◊§◊î ◊ò◊ë◊¢◊ô◊™ ◊ë◊ê◊û◊¶◊¢◊ï◊™ ◊î◊°◊™◊ë◊®◊ï◊ô◊ï◊™: ◊û◊ï◊ì◊ú ◊î◊©◊§◊î ◊ô◊õ◊ï◊ú ◊ú◊ó◊©◊ë ◊î◊°◊™◊ë◊®◊ï◊™ ◊ú◊õ◊ú ◊û◊©◊§◊ò ◊ë◊©◊§◊î ◊©◊ë◊î ◊ê◊ô◊û◊†◊ï ◊ê◊ï◊™◊ï, ◊ï◊õ◊ö ◊î◊ï◊ê ◊ô◊õ◊ï◊ú ◊ú◊ô◊ô◊¶◊® ◊û◊©◊§◊ò◊ô◊ù ◊ó◊ì◊©◊ô◊ù, ◊û◊ô◊ú◊î ◊ê◊ó◊® ◊û◊ô◊ú◊î. ◊û◊ï◊ì◊ú ◊î◊©◊§◊î ◊ú◊û◊¢◊©◊î ‚Äú◊û◊û◊©◊ô◊ö ◊ê◊™ ◊î◊û◊©◊§◊ò‚Äù: ◊û◊ñ◊ô◊†◊ô◊ù ◊î◊™◊ó◊ú◊î ◊©◊ú ◊û◊©◊§◊ò, ◊ï◊î◊ï◊ê ◊û◊û◊©◊ô◊ö. ◊î◊©◊ô◊û◊ï◊©◊ô◊ù ◊î◊ù ◊õ◊û◊¢◊ò ◊ê◊ô◊†◊°◊ï◊§◊ô◊ô◊ù: ◊ê◊§◊©◊® ◊ú◊ë◊ß◊© ◊û◊î◊û◊ï◊ì◊ú ◊ú◊¢◊†◊ï◊™ ◊¢◊ú ◊©◊ê◊ú◊ï◊™, ◊ú◊°◊õ◊ù ◊ò◊ß◊°◊ò◊ô◊ù, ◊ú◊ó◊ë◊® ◊©◊ô◊®◊ô◊ù, ◊ú◊õ◊™◊ï◊ë ◊§◊ï◊†◊ß◊¶◊ô◊ï◊™ ◊ë◊©◊§◊ï◊™ ◊™◊õ◊†◊ï◊™ ◊©◊ï◊†◊ï◊™ ◊ï◊ê◊§◊ô◊ú◊ï ◊ú◊ô◊ô◊¶◊® ◊™◊û◊ï◊†◊ï◊™ ◊ë◊¶◊ï◊®◊î ◊°◊ô◊†◊™◊ò◊ô◊™.◊ê◊ë◊ú ◊ú◊ê ◊î◊õ◊ú ◊û◊ï◊©◊ú◊ù, ◊ï◊ê◊ó◊ì ◊î◊§◊í◊û◊ô◊ù ◊ë◊™◊§◊ß◊ï◊ì ◊©◊ú LLMs ◊î◊ï◊ê ◊î◊î◊ñ◊ô◊ï◊™ ◊î◊û◊ï◊õ◊®◊ï◊™ ◊ú◊õ◊ï◊ú◊†◊ï ‚Äì ◊ê◊ï◊™◊ù ◊û◊ß◊®◊ô◊ù ◊©◊ë◊î◊ù ◊û◊ï◊ì◊ú◊ô ◊©◊§◊î ◊û◊°◊§◊ß◊ô◊ù ◊™◊©◊ï◊ë◊ï◊™ ◊©◊í◊ï◊ô◊ï◊™ ◊¢◊ï◊ë◊ì◊™◊ô◊™, ◊ú◊ê ◊®◊ú◊ï◊ï◊†◊ò◊ô◊ï◊™ ◊ê◊ï ◊û◊ï◊§◊®◊õ◊ï◊™ ◊ú◊ó◊ú◊ï◊ò◊ô◊ü. ◊õ◊ì◊ô ◊ú◊î◊ï◊°◊ô◊£ ◊ó◊ò◊ê ◊¢◊ú ◊§◊©◊¢, ◊û◊ï◊ì◊ú◊ô ◊î◊©◊§◊î ◊ú◊ê ◊™◊û◊ô◊ì ◊û◊°◊ô◊ô◊í◊ô◊ù ◊ê◊™ ◊™◊©◊ï◊ë◊ï◊™◊ô◊î◊ù ◊ï◊¢◊ï◊†◊ô◊ù ◊ë◊ë◊ô◊ò◊ó◊ï◊ü ◊û◊ú◊ê, ◊ï◊ú◊õ◊ü ◊î◊î◊ñ◊ô◊ï◊™ ◊î◊ü ◊û◊°◊ï◊õ◊†◊ï◊™ ◊ï◊ß◊©◊ï◊™ ◊ú◊í◊ô◊ú◊ï◊ô.◊ê◊ó◊™ ◊î◊ì◊®◊õ◊ô◊ù ◊ú◊î◊™◊û◊ï◊ì◊ì ◊¢◊ù ◊™◊ï◊§◊¢◊™ ◊î◊î◊ñ◊ô◊ï◊™ ◊î◊ô◊ê RAG: Retrieval Augmented Generation (◊ê◊ï ◊ë◊¢◊ë◊®◊ô◊™, ‚Äú◊õ◊™◊ô◊ë◊™ ◊ò◊ß◊°◊ò ◊ë◊¢◊ñ◊®◊™ ◊©◊ú◊ô◊§◊î ◊ï◊î◊¢◊©◊®◊î ◊ë◊ô◊ì◊¢‚Äù). ◊ë◊©◊ô◊ò◊î ◊ñ◊ï, ◊û◊ï◊ì◊ú ◊î◊©◊§◊î ◊†◊¢◊ñ◊® ◊ë◊ô◊ì◊¢ ◊ó◊ô◊¶◊ï◊†◊ô ◊©◊ê◊ï◊™◊ï ◊î◊ï◊ê ◊©◊ï◊ú◊£ ◊ê◊ï ◊û◊ß◊ë◊ú ◊ú◊¶◊ï◊®◊ö ◊î◊©◊ú◊û◊™ ◊î◊û◊©◊ô◊û◊î, ◊õ◊ì◊ô ◊©◊î◊™◊©◊ï◊ë◊ï◊™ ◊ô◊î◊ô◊ï ◊û◊ì◊ï◊ô◊ß◊ï◊™ ◊ô◊ï◊™◊®. RAG ◊î◊ï◊ê ◊©◊ù ◊õ◊ï◊ú◊ú ◊ú◊õ◊ú ◊î◊ò◊õ◊†◊ô◊ß◊ï◊™ ◊ú◊ë◊†◊ô◊ô◊™ ◊û◊¢◊®◊õ◊ï◊™ ◊©◊ë◊î◊ü ◊û◊ó◊ë◊®◊ô◊ù ◊û◊ï◊ì◊ú◊ô ◊©◊§◊î ◊ú◊ô◊ì◊¢ ◊ó◊ô◊¶◊ï◊†◊ô ◊ú◊¶◊ï◊®◊ö ◊©◊ô◊§◊ï◊® ◊î◊™◊ï◊¶◊ê◊ï◊™.◊û◊¢◊®◊õ◊™ RAG ◊õ◊ï◊ú◊ú◊™ ◊û◊ê◊í◊® ◊ô◊ì◊¢ ◊õ◊í◊ï◊ü ◊ë◊°◊ô◊° ◊†◊™◊ï◊†◊ô◊ù, ◊ê◊ï◊°◊£ ◊©◊ú ◊û◊°◊û◊õ◊ô◊ù ◊ï◊ê◊§◊ô◊ú◊ï ◊õ◊ú◊ô ◊ó◊ô◊§◊ï◊© ◊ë◊í◊ï◊í◊ú. ◊õ◊©◊ê◊†◊ó◊†◊ï ◊û◊ñ◊ô◊†◊ô◊ù ◊ë◊ß◊©◊î ◊ú◊û◊¢◊®◊õ◊™, ◊î◊ô◊ê ◊û◊ê◊™◊®◊™ ◊§◊ô◊°◊ï◊™ ◊û◊ô◊ì◊¢ ◊®◊ú◊ï◊ï◊†◊ò◊ô◊ï◊™ ◊ë◊™◊ï◊ö ◊û◊ê◊í◊®◊ô ◊î◊ô◊ì◊¢. ◊ê◊ú◊î ◊¢◊ï◊ë◊®◊ô◊ù ◊ô◊ó◊ì ◊¢◊ù ◊î◊ë◊ß◊©◊î ◊î◊û◊ß◊ï◊®◊ô◊™ ◊ê◊ú ◊û◊ï◊ì◊ú ◊î◊©◊§◊î, ◊ï◊î◊ï◊ê ◊¢◊ï◊†◊î ◊¢◊ú ◊î◊ë◊ß◊©◊î ‚Äì ◊ë◊™◊ß◊ï◊ï◊î ◊©◊î◊™◊©◊ï◊ë◊î ◊™◊î◊ô◊î ◊û◊ú◊ê◊î, ◊û◊ì◊ï◊ô◊ß◊™ ◊ï◊®◊ú◊ï◊ï◊†◊ò◊ô◊™, ◊ë◊ñ◊õ◊ï◊™ ◊î◊û◊ô◊ì◊¢ ◊©◊î◊û◊ï◊ì◊ú ◊ß◊ô◊ë◊ú. ◊ê◊ó◊ñ◊ï◊® ◊û◊ô◊ì◊¢ (retrieval) ◊®◊ú◊ï◊ï◊†◊ò◊ô ◊ï◊î◊¢◊ë◊®◊™◊ï ◊ú◊û◊ï◊ì◊ú ◊î◊©◊§◊î ◊û◊©◊§◊®◊ô◊ù ◊ë◊ê◊ï◊§◊ü ◊û◊ï◊õ◊ó ◊ï◊û◊©◊û◊¢◊ï◊™◊ô ◊ê◊™ ◊î◊ë◊ô◊¶◊ï◊¢◊ô◊ù ◊©◊ú ◊û◊ï◊ì◊ú◊ô ◊©◊§◊î ◊ë◊û◊í◊ï◊ï◊ü ◊û◊©◊ô◊û◊ï◊™ ◊î◊û◊¶◊®◊ô◊õ◊ï◊™ ◊ô◊ì◊¢ ‚Äì ◊õ◊ï◊ú◊ú ◊û◊¢◊†◊î ◊¢◊ú ◊©◊ê◊ú◊ï◊™ (Q&amp;A), ◊û◊ô◊ï◊ü (Classification), ◊°◊ô◊õ◊ï◊ù ◊ï◊¢◊ï◊ì.◊ú◊û◊¢◊®◊õ◊ï◊™ RAG ◊ô◊©◊†◊ù ◊©◊ô◊û◊ï◊©◊ô◊ù ◊©◊ï◊†◊ô◊ù, ◊ï◊î◊ô◊™◊®◊ï◊ü ◊î◊û◊ï◊ë◊î◊ß ◊©◊ú◊î◊ü ◊î◊ï◊ê ◊î◊ô◊õ◊ï◊ú◊™ ◊ú◊®◊™◊ï◊ù ◊û◊ê◊í◊®◊ô ◊ô◊ì◊¢ ◊ë◊û◊ò◊®◊î ◊ú◊î◊©◊ú◊ô◊ù ◊ê◊™ ◊î◊û◊©◊ô◊û◊î. ◊û◊ê◊í◊®◊ô◊ù ◊ê◊ú◊î ◊î◊ù ◊î◊ì◊®◊ö ◊î◊¢◊ô◊ß◊®◊ô◊™ ◊ú◊î◊ï◊°◊ô◊£ ◊ô◊ì◊¢ ◊ó◊ì◊© ◊ï◊ú◊¢◊ì◊õ◊ü ◊ô◊ì◊¢ ◊ß◊ô◊ô◊ù ◊ë◊û◊ï◊ì◊ú◊ô ◊î◊©◊§◊î, ◊ï◊ú◊õ◊ü ◊î◊ù ◊û◊ï◊¶◊ú◊ó◊ô◊ù ◊õ◊ú ◊õ◊ö. ◊ë◊†◊ï◊°◊£, ◊ë◊ó◊ô◊®◊î ◊ì◊ô◊†◊û◊ô◊™ ◊©◊ú ◊û◊ê◊í◊®◊ô ◊î◊ô◊ì◊¢ ◊§◊ï◊™◊ó◊™ ◊ê◊™ ◊î◊ì◊ú◊™ ◊ú◊û◊ï◊ì◊ú◊ô ◊©◊§◊î ◊û◊ï◊™◊ê◊û◊ô◊ù ◊ê◊ô◊©◊ô◊™.◊ß◊ó◊ï ◊ú◊ì◊ï◊í◊û◊î ◊¢◊ï◊ñ◊® ◊ê◊ô◊©◊ô (digital assistant). ◊ë◊û◊ß◊®◊î ◊î◊ñ◊î ◊û◊¢◊®◊õ◊™ ◊î-RAG ◊û◊ó◊ï◊ë◊®◊™ ◊ú◊û◊ê◊í◊®◊ô ◊ô◊ì◊¢ ◊û◊ß◊¶◊ï◊¢◊ô◊ô◊ù. ◊ë◊ñ◊õ◊ï◊™ ◊î◊ô◊õ◊ï◊ú◊ï◊™ ◊©◊ú ◊û◊ï◊ì◊ú ◊î◊©◊§◊î, ◊î◊û◊¢◊®◊õ◊™ ◊ô◊õ◊ï◊ú◊î ◊ú◊©◊ï◊ó◊ó ◊ë◊©◊§◊î ◊ò◊ë◊¢◊ô◊™ ◊¢◊ú ◊û◊í◊ï◊ï◊ü ◊†◊ï◊©◊ê◊ô◊ù ◊ò◊õ◊†◊ô◊ô◊ù, ◊ú◊ô◊ô◊¢◊• ◊ï◊ú◊¢◊†◊ï◊™ ◊¢◊ú ◊©◊ê◊ú◊ï◊™. ◊ë◊†◊ï◊°◊£, ◊î◊û◊¢◊®◊õ◊™ ◊ô◊õ◊ï◊ú◊î ◊ú◊î◊§◊†◊ï◊™ ◊ê◊™ ◊î◊û◊©◊™◊û◊© ◊ú◊û◊ß◊ï◊®◊ï◊™ ◊î◊ô◊ì◊¢ ◊¢◊¶◊û◊ù (◊ë◊ê◊û◊¶◊¢◊ï◊™ ◊¶◊ô◊ò◊ï◊ò, citation), ◊õ◊û◊¢◊ô◊ü ◊¢◊ï◊ñ◊® ◊û◊ó◊ß◊®.◊ì◊ï◊í◊û◊î ◊†◊ï◊°◊§◊™ ◊î◊ô◊ê ◊©◊ô◊û◊ï◊© ◊ë◊ô◊ì◊¢ ◊©◊ú ◊î◊û◊©◊™◊û◊© ◊¢◊¶◊û◊ï, ◊õ◊ú◊ï◊û◊® ‚Äì ◊û◊ê◊í◊® ◊î◊ô◊ì◊¢ ◊û◊ë◊ï◊°◊° ◊¢◊ú ◊î◊ì◊ê◊ò◊î ◊©◊ú ◊î◊û◊©◊™◊û◊©, ◊ï◊õ◊ö ◊û◊¢◊®◊õ◊™ ◊î-RAG ◊û◊™◊ê◊ô◊û◊î ◊ú◊ï ◊ê◊™ ◊™◊©◊ï◊ë◊ï◊™◊ô◊î. ◊î◊û◊©◊™◊û◊© ◊ô◊õ◊ï◊ú ◊ú◊î◊¢◊ú◊ï◊™ ◊ê◊ï◊°◊£ ◊ß◊ë◊¶◊ô◊ù ◊ê◊ô◊©◊ô◊ô◊ù ◊ú◊û◊¢◊®◊õ◊™ ◊ï◊ú◊ë◊ß◊© ◊û◊û◊†◊î ◊ú◊°◊õ◊ù ◊†◊ï◊©◊ê◊ô◊ù ◊î◊û◊ï◊§◊ô◊¢◊ô◊ù ◊ë◊û◊°◊û◊õ◊ô◊ù, ◊ú◊©◊ê◊ï◊ú ◊î◊ô◊õ◊ü ◊†◊û◊¶◊ê ◊ì◊ô◊ï◊ü ◊ë◊†◊ï◊©◊ê ◊õ◊ñ◊î ◊ê◊ï ◊ê◊ó◊®, ◊ú◊ë◊ß◊© ◊©◊™◊®◊õ◊ô◊ë ◊û◊¶◊í◊™ ◊°◊ô◊õ◊ï◊ù ◊û◊î◊û◊°◊û◊õ◊ô◊ù ◊ï◊õ◊ü ◊î◊ú◊ê◊î.◊õ◊ê◊©◊® ◊†◊ô◊í◊©◊ô◊ù ◊ú◊ë◊†◊ï◊™ ◊û◊¢◊®◊õ◊™ RAG ◊¶◊®◊ô◊ö ◊ú◊ß◊ë◊ú ◊î◊ó◊ú◊ò◊ï◊™ ◊®◊ë◊ï◊™. ◊ë◊©◊ú◊ë ◊î◊®◊ê◊©◊ï◊ü ◊¢◊ú◊ô◊†◊ï ◊ú◊ë◊ó◊ï◊® ◊û◊ï◊ì◊ú ◊©◊§◊î ‚Äì ◊§◊™◊ï◊ó ◊ê◊ï ◊°◊í◊ï◊®. ◊û◊ï◊ì◊ú ◊°◊í◊ï◊® ◊î◊ï◊ê ◊û◊ï◊ì◊ú ◊û◊°◊ó◊®◊ô ◊ê◊ô◊™◊ï ◊¢◊ï◊ë◊ì◊ô◊ù ◊ë◊¢◊ñ◊®◊™ ◊û◊û◊©◊ß API, ◊ï◊ê◊ô◊ü ◊ú◊†◊ï ◊í◊ô◊©◊î ◊ú◊ê◊ï◊§◊ü ◊§◊¢◊ï◊ú◊™ ◊î◊û◊ï◊ì◊ú ◊ê◊ï ◊î◊û◊©◊ß◊ï◊ú◊ï◊™ ◊©◊ú◊ï. ◊ú◊¢◊ï◊û◊™◊ï, ◊ë◊û◊ï◊ì◊ú ◊§◊™◊ï◊ó ◊í◊ù ◊î◊ß◊ï◊ì ◊ï◊í◊ù ◊î◊û◊©◊ß◊ï◊ú◊ï◊™ ◊†◊í◊ô◊©◊ô◊ù ◊ú◊ë◊ó◊ô◊†◊î, ◊ê◊ô◊û◊ï◊ü ◊ï◊î◊í◊©◊î (inference). ◊ê◊™ ◊î◊û◊ï◊ì◊ú ◊î◊§◊™◊ï◊ó ◊†◊ô◊™◊ü ◊ú◊î◊™◊ê◊ô◊ù ◊ú◊¢◊ï◊ú◊ù ◊î◊™◊ï◊õ◊ü ◊©◊ú◊†◊ï ◊ë◊¢◊ñ◊®◊™ ◊ê◊ô◊û◊ï◊ü fine tuning. ◊ë◊ó◊ú◊ß ◊û◊î◊û◊ß◊®◊ô◊ù ◊î◊í◊©◊î ◊¢◊¶◊û◊ô◊™ ◊©◊ú ◊û◊ï◊ì◊ú◊ô◊ù ◊§◊™◊ï◊ó◊ô◊ù ◊¢◊©◊ï◊ô◊î ◊ú◊î◊ô◊ï◊™ ◊¢◊ì◊ô◊§◊î ◊¢◊ú ◊§◊†◊ô ◊û◊ï◊ì◊ú◊ô◊ù ◊°◊í◊ï◊®◊ô◊ù, ◊ê◊ö ◊î◊ô◊ê ◊û◊¶◊®◊ô◊õ◊î ◊û◊ô◊ï◊û◊†◊ï◊™.◊î◊ó◊ú◊ß ◊î◊©◊†◊ô ◊ë◊ë◊†◊ô◊ô◊™ ◊û◊¢◊®◊õ◊™ RAG ◊î◊ï◊ê ◊ó◊ô◊ë◊ï◊® ◊ú◊û◊ê◊í◊®◊ô ◊ô◊ì◊¢. ◊ú◊ó◊ô◊ë◊ï◊® ◊î◊ñ◊î ◊ô◊©◊†◊ù ◊î◊ô◊ë◊ò◊ô◊ù ◊®◊ë◊ô◊ù, ◊î◊õ◊ï◊ú◊ú◊ô◊ù ◊ê◊™ ◊ê◊ï◊§◊ü ◊ê◊ô◊†◊ì◊ï◊ß◊° ◊î◊ô◊ì◊¢, ◊¢◊ô◊ë◊ï◊ì ◊û◊ß◊ì◊ô◊ù ◊©◊ú ◊î◊ò◊ß◊°◊ò ◊ï◊î◊™◊û◊ï◊†◊ï◊™, ◊ó◊ú◊ï◊ß◊î ◊ú◊§◊°◊ß◊ê◊ï◊™ ◊ê◊ï ◊û◊©◊§◊ò◊ô◊ù, ◊†◊ô◊ß◊ï◊ô, ◊¢◊ô◊ë◊ï◊ì ◊©◊ú ◊ì◊ê◊ò◊î ◊ò◊ë◊ú◊ê◊ô, ◊î◊û◊®◊™ ◊î◊ì◊ê◊ò◊î ◊ú◊ô◊ô◊¶◊ï◊í ◊ï◊ß◊ò◊ï◊®◊ô (vector embedding) ◊©◊ô◊õ◊ï◊ú ◊ú◊©◊§◊® ◊ê◊™ ◊ê◊ô◊õ◊ï◊™ ◊î◊ó◊ô◊§◊ï◊©, ◊ó◊ô◊§◊ï◊© ◊û◊ë◊ï◊°◊° ◊û◊ô◊ú◊ô◊ù, ◊ó◊ô◊§◊ï◊© ◊°◊û◊†◊ò◊ô ◊ê◊ï ◊©◊ô◊ú◊ï◊ë ◊©◊ú◊î◊ù, ◊û◊°◊§◊® ◊î◊ì◊ï◊í◊û◊ê◊ï◊™ ◊ú◊ê◊ó◊ñ◊ï◊®, ◊û◊ô◊ï◊ü ◊®◊ú◊ï◊ï◊†◊ò◊ô◊ï◊™, ◊°◊ô◊†◊ï◊ü, ◊©◊ô◊õ◊™◊ï◊ë ◊î◊ì◊ï◊í◊û◊ê◊ï◊™, ◊°◊ô◊õ◊ï◊ù ◊ï◊¢◊ï◊ì. ◊ñ◊î ◊û◊û◊© ◊¢◊ú ◊ß◊¶◊î ◊î◊û◊ñ◊ú◊í, ◊ï◊®◊ß ◊¢◊ú ◊î◊©◊ú◊ë ◊î◊ñ◊î ◊ô◊õ◊ï◊ú◊™◊ô ◊ú◊õ◊™◊ï◊ë ◊û◊ê◊û◊® ◊©◊ú◊ù. ◊î◊ó◊ú◊ß ◊î◊ñ◊î ◊ß◊®◊ô◊ò◊ô, ◊õ◊ô ◊õ◊û◊ï ◊©◊ê◊ï◊û◊®◊ô◊ù ‚Äì garbage in, garbage out: ◊ê◊ù ◊ê◊ó◊ñ◊ï◊® ◊î◊ô◊ì◊¢ ◊ô◊î◊ô◊î ◊ú◊ê ◊û◊ì◊ï◊ô◊ß ◊ï◊ú◊ê ◊®◊ú◊ï◊ï◊†◊ò◊ô ◊û◊°◊§◊ô◊ß, ◊ê◊ô◊õ◊ï◊™ ◊î◊™◊©◊ï◊ë◊ï◊™ ◊©◊ú ◊û◊ï◊ì◊ú ◊î◊©◊§◊î ◊™◊§◊í◊¢◊†◊î ◊û◊ô◊ì, ◊ï◊î◊°◊ô◊õ◊ï◊ô ◊ú◊î◊ñ◊ô◊ï◊™ ◊ô◊í◊ì◊ú.◊ú◊ê◊ó◊® ◊û◊õ◊ü ◊†◊ô◊™◊ü ◊ú◊î◊ï◊°◊ô◊£ ◊û◊®◊õ◊ô◊ë◊ô◊ù ◊ú◊û◊¢◊®◊õ◊™: ◊û◊ï◊ì◊ú◊ô ◊©◊§◊î ◊†◊ï◊°◊§◊ô◊ù ◊©◊†◊ë◊ó◊®◊ô◊ù ◊ë◊¶◊ï◊®◊î ◊ì◊ô◊†◊û◊ô◊™ ◊¢◊ú ◊§◊ô ◊ê◊ï◊§◊ô ◊î◊û◊©◊ô◊û◊î; ◊©◊ô◊û◊ï◊© ◊ë◊õ◊û◊î ◊û◊ê◊í◊®◊ô ◊ô◊ì◊¢ ◊ë◊û◊ß◊ë◊ô◊ú; ◊©◊ô◊û◊ï◊© ◊ë◊õ◊ú◊ô◊ù ◊î◊û◊ï◊ì◊ì◊ô◊ù ◊ê◊™ ◊ê◊ô◊õ◊ï◊™ ◊î◊û◊°◊û◊õ◊ô◊ù ◊©◊†◊û◊¶◊ê◊ï, ◊õ◊ö ◊©◊†◊ô◊™◊ü ◊ô◊î◊ô◊î ◊ú◊ú◊ß◊ò ◊ê◊™ ◊ß◊ò◊¢◊ô ◊î◊û◊ô◊ì◊¢ ◊î◊®◊ú◊ï◊ï◊†◊ò◊ô◊ô◊ù ◊ë◊ô◊ï◊™◊® ◊û◊™◊ï◊ö ◊î◊û◊°◊û◊õ◊ô◊ù ◊©◊ó◊ñ◊®◊ï; ◊û◊ï◊ì◊ú◊ô ◊©◊§◊î ◊©◊ô◊ï◊ì◊¢◊ô◊ù ◊ú◊ë◊ß◊© ◊ë◊ô◊¶◊ï◊¢ ◊ê◊ó◊ñ◊ï◊® ◊†◊ï◊°◊£ ◊ê◊ù ◊î◊ù ◊ú◊ê ◊û◊¶◊ê◊ï ◊¢◊ì◊ô◊ô◊ü ◊ê◊™ ◊î◊™◊©◊ï◊ë◊î ◊©◊ó◊ô◊§◊©◊ï; ◊ï◊î◊®◊©◊ô◊û◊î ◊û◊û◊©◊ô◊õ◊î, ◊õ◊ô◊ê◊î ◊ú◊™◊ó◊ï◊ù ◊û◊ó◊ß◊® ◊§◊¢◊ô◊ú ◊ë◊ô◊ï◊™◊®.◊î◊ê◊™◊í◊® ◊î◊¢◊ô◊ß◊®◊ô ◊ë◊ë◊†◊ô◊ô◊™ ◊û◊¢◊®◊õ◊™ RAG ◊î◊ï◊ê ◊ú◊î◊í◊ô◊¢ ◊ú◊®◊û◊™ ◊ê◊ô◊õ◊ï◊™ ◊ï◊ì◊ô◊ï◊ß ◊û◊ß◊°◊ô◊û◊ú◊ô◊ô◊ù. ◊õ◊ú ◊ó◊ú◊ß◊ô ◊î◊û◊¢◊®◊õ◊™ ◊û◊©◊§◊ô◊¢◊ô◊ù ◊¢◊ú ◊î◊™◊©◊ï◊ë◊ï◊™ ◊î◊°◊ï◊§◊ô◊ï◊™, ◊ï◊ú◊õ◊ü ◊û◊ï◊õ◊®◊ó◊ô◊ù ◊ú◊™◊õ◊†◊ü ◊ê◊ï◊™◊î ◊ë◊ß◊§◊ì◊†◊ï◊™. ◊õ◊ó◊ú◊ß ◊û◊î◊î◊õ◊†◊î, ◊õ◊ì◊ê◊ô ◊ú◊ë◊ó◊ï◊ü ◊ï◊ú◊î◊©◊ï◊ï◊™ ◊û◊ï◊ì◊ú◊ô ◊©◊§◊î ◊¢◊ú ◊û◊†◊™ ◊ú◊î◊í◊ô◊¢ ◊ú◊©◊ô◊ú◊ï◊ë ◊®◊ê◊ï◊ô ◊©◊ú ◊¢◊ú◊ï◊™ ◊û◊ï◊ú ◊ì◊ô◊ï◊ß. ◊ë◊ó◊ô◊®◊™ ◊û◊ê◊í◊®◊ô ◊î◊ô◊ì◊¢, ◊ê◊ï◊§◊ô ◊î◊ê◊ó◊°◊ï◊ü, ◊ê◊ó◊ñ◊ï◊® ◊ï◊î◊¶◊í◊™ ◊î◊ô◊ì◊¢ ◊ú◊û◊ï◊ì◊ú ◊î◊ù ◊ß◊®◊ô◊ò◊ô◊ô◊ù ◊ë◊ô◊ô◊¶◊ï◊® ◊™◊©◊ï◊ë◊ï◊™ ◊†◊õ◊ï◊†◊ï◊™ ◊ï◊®◊ú◊ï◊ï◊†◊ò◊ô◊ï◊™ ◊ë◊ñ◊û◊ü ◊®◊ô◊¶◊î ◊°◊ë◊ô◊®. ◊õ◊ì◊ô ◊ú◊ë◊ó◊ï◊ü ◊ê◊™ ◊ò◊ô◊ë ◊î◊û◊¢◊®◊õ◊™ ◊©◊ë◊†◊ô◊™◊ù, ◊†◊ô◊™◊ü ◊ú◊î◊©◊™◊û◊© ◊ë◊ì◊ï◊í◊û◊ê◊ï◊™ ◊û◊™◊ï◊ô◊í◊ï◊™ (◊ì◊ï◊í◊û◊ê◊ï◊™ ◊î◊û◊õ◊ô◊ú◊ï◊™ ◊™◊©◊ï◊ë◊ï◊™ ◊ô◊ì◊ï◊¢◊ï◊™ ◊û◊®◊ê◊©) ◊ï◊ú◊ë◊¶◊¢ ◊ë◊ó◊ô◊†◊î ◊ô◊ì◊†◊ô◊™ ◊ê◊ï ◊ê◊ï◊ò◊ï◊û◊ò◊ô◊™ ◊©◊ú ◊î◊™◊ï◊¶◊ê◊ï◊™.◊î◊û◊ï◊®◊õ◊ë◊ï◊™ ◊î◊í◊ì◊ï◊ú◊î ◊†◊ï◊ë◊¢◊™ ◊ë◊¢◊ô◊ß◊® ◊û◊î◊î◊™◊†◊î◊í◊ï◊™ ◊î◊ú◊ê ◊¶◊§◊ï◊ô◊î ◊ú◊¢◊™◊ô◊ù ◊©◊ú LLMs. ◊ú◊ì◊ï◊í◊û◊î, ◊ë◊ó◊ú◊ß ◊ß◊ò◊ü ◊û◊î◊û◊ß◊®◊ô◊ù ◊û◊ï◊ì◊ú ◊î◊©◊§◊î ◊ô◊©◊í◊î, ◊ê◊§◊ô◊ú◊ï ◊©◊î◊ô◊ì◊¢ ◊©◊ß◊ô◊ë◊ú ◊û◊õ◊ô◊ú ◊ê◊™ ◊î◊™◊©◊ï◊ë◊î ◊î◊†◊õ◊ï◊†◊î. ◊î◊°◊ô◊ë◊ï◊™ ◊ú◊ê ◊ë◊®◊ï◊®◊ï◊™ ◊†◊ï◊ë◊¢◊ï◊™ ◊û◊°◊™◊ô◊®◊î ◊ë◊ô◊ü ◊î◊ô◊ì◊¢ ◊î◊§◊†◊ô◊û◊ô ◊©◊ú ◊î◊û◊ï◊ì◊ú ◊ú◊ô◊ì◊¢ ◊î◊û◊ï◊¶◊í ◊ë◊§◊†◊ô◊ï. ◊î◊¶◊ï◊ï◊™ ◊©◊ú◊†◊ï ◊ó◊ï◊ß◊® ◊ì◊®◊õ◊ô◊ù ◊ë◊î◊ü ◊†◊ô◊™◊ü ◊ú◊©◊ú◊ï◊ò ◊ë◊î◊™◊†◊î◊í◊ï◊™ ◊î◊û◊ï◊ì◊ú◊ô◊ù ◊ë◊û◊ß◊®◊ô◊ù ◊õ◊ê◊ú◊î, ◊ë◊¢◊ñ◊®◊™ ◊î◊ï◊®◊ê◊ï◊™ ◊û◊ï◊™◊ê◊û◊ï◊™ ◊ï◊ê◊ô◊û◊ï◊ü ◊†◊ï◊°◊£.◊ô◊ó◊ì ◊¢◊ù ◊ñ◊ê◊™, ◊†◊ô◊™◊ü ◊ú◊©◊§◊® ◊ê◊™ ◊ê◊ô◊õ◊ï◊™ ◊î◊û◊¢◊®◊õ◊™ ◊õ◊ï◊ú◊î ◊ë◊ê◊û◊¶◊¢◊ï◊™ ◊î◊™◊ê◊û◊™ ◊î◊û◊ï◊ì◊ú ◊ú◊ë◊ô◊¶◊ï◊¢ ◊û◊©◊ô◊û◊ï◊™ RAG. ◊ú◊¶◊ï◊®◊ö ◊õ◊ö, ◊î◊¶◊ï◊ï◊™ ◊©◊ú◊†◊ï ◊§◊ô◊™◊ó ◊õ◊ú◊ô ◊ß◊ï◊ì ◊§◊™◊ï◊ó ◊©◊û◊ê◊§◊©◊® ◊ú◊ê◊û◊ü ◊ï◊ú◊©◊§◊® ◊ê◊™ ◊ô◊õ◊ï◊ú◊ï◊™ ◊î-RAG ◊©◊ú ◊û◊ï◊ì◊ú◊ô ◊©◊§◊î.◊õ◊ì◊ô ◊ú◊ë◊†◊ï◊™ ◊û◊¢◊®◊õ◊™ RAG ◊ê◊ô◊õ◊ï◊™◊ô◊™ ◊ï◊û◊ì◊ï◊ô◊ß◊™, ◊†◊ì◊®◊©◊™ ◊î◊ë◊†◊î ◊¢◊û◊ï◊ß◊î ◊©◊ú ◊î◊î◊ô◊ë◊ò◊ô◊ù ◊î◊©◊ï◊†◊ô◊ù ◊©◊ú◊î. ◊õ◊û◊ï◊ë◊ü ◊©◊ê◊ô ◊ê◊§◊©◊® ◊ú◊ï◊ï◊™◊® ◊¢◊ú ◊™◊î◊ú◊ô◊ö ◊†◊ô◊°◊ï◊ô ◊ï◊ò◊¢◊ô◊î, ◊©◊¢◊ï◊ñ◊® ◊ú◊©◊§◊ï◊ö ◊ê◊ï◊® ◊¢◊ú ◊î◊§◊©◊®◊ï◊™ ◊î◊©◊ï◊†◊ï◊™ ◊î◊õ◊®◊ï◊õ◊ï◊™ ◊ë◊¢◊ô◊¶◊ï◊ë ◊î◊û◊¢◊®◊õ◊™. ◊®◊ß ◊õ◊ö ◊†◊ï◊õ◊ú ◊ú◊ë◊†◊ï◊™ ◊ê◊™ ◊î◊û◊¢◊®◊õ◊™ ◊î◊ê◊ô◊ì◊ô◊ê◊ú◊ô◊™ ◊ú◊ë◊¢◊ô◊î ◊©◊ê◊ï◊™◊î ◊ê◊†◊ó◊†◊ï ◊û◊†◊°◊ô◊ù ◊ú◊§◊™◊ï◊®.◊û◊¢◊®◊õ◊ï◊™ RAG ◊û◊ô◊ô◊¶◊í◊ï◊™ ◊ê◊®◊õ◊ô◊ò◊ß◊ò◊ï◊®◊î ◊ó◊ì◊©◊î ◊î◊û◊©◊ú◊ë◊™ ◊û◊ï◊ì◊ú◊ô ◊©◊§◊î ◊¢◊ù ◊û◊ê◊í◊®◊ô ◊†◊™◊ï◊†◊ô◊ù. ◊ë◊ñ◊õ◊ï◊™ ◊î◊©◊ô◊ú◊ï◊ë ◊î◊ñ◊î ◊ô◊© ◊ú◊î◊ù ◊§◊ï◊ò◊†◊¶◊ô◊ê◊ú ◊ú◊ë◊¶◊¢ ◊û◊©◊ô◊û◊ï◊™ ◊¢◊™◊ô◊®◊ï◊™ ◊ô◊ì◊¢, ◊õ◊í◊ï◊ü ◊¢◊ï◊ñ◊®◊ô◊ù ◊ì◊ô◊í◊ô◊ò◊ú◊ô◊ô◊ù ◊û◊ï◊™◊ê◊û◊ô◊ù ◊ê◊ô◊©◊ô◊™, ◊¶‚Äô◊ê◊ò◊ë◊ï◊ò ◊ë◊©◊ô◊®◊ï◊™ ◊ú◊ß◊ï◊ó◊ï◊™ ◊ï◊û◊¢◊®◊õ◊ï◊™ ◊ô◊ì◊¢ ◊ê◊®◊í◊ï◊†◊ô◊ï◊™. ◊ï◊ê◊ù ◊ú◊©◊§◊ï◊ò ◊ú◊§◊ô ◊î◊û◊ó◊ß◊® ◊î◊§◊¢◊ô◊ú ◊ë◊™◊ó◊ï◊ù, ◊ñ◊ï◊î◊ô ◊®◊ß ◊î◊î◊™◊ó◊ú◊î.◊î◊õ◊ï◊™◊ë ◊î◊ï◊ê ◊ó◊ï◊ß◊® ◊ë◊û◊¢◊ë◊ì◊™ ◊î÷æNLP ◊ë◊ê◊®◊í◊ï◊ü Intel Labs. ◊ë◊û◊¢◊ë◊ì◊î ◊†◊ó◊ß◊®◊ï◊™ ◊°◊ï◊í◊ô◊ï◊™ ◊î◊ß◊©◊ï◊®◊ï◊™ ◊ú◊û◊ï◊ì◊ú◊ô ◊©◊§◊î ◊õ◊í◊ï◊ü RAG ,Efficient Inference, ◊¢◊ë◊ï◊ì◊î ◊¢◊ù ◊ß◊ï◊†◊ò◊ß◊°◊ò◊ô◊ù ◊ê◊®◊ï◊õ◊ô◊ù, ◊©◊ô◊û◊ï◊© ◊ë◊°◊ï◊õ◊†◊ô◊ù ◊ï◊¢◊ï◊ì.◊ê◊ô◊†◊ò◊ú ◊û◊û◊©◊ô◊õ◊î ◊ú◊î◊ï◊ë◊ô◊ú ◊ê◊™ ◊™◊ó◊ï◊ù ◊î◊ë◊ô◊†◊î ◊î◊û◊ú◊ê◊õ◊ï◊™◊ô◊™ ◊¢◊ù ◊î◊§◊™◊®◊ï◊†◊ï◊™ ◊î◊û◊™◊ß◊ì◊û◊ô◊ù ◊ë◊ô◊ï◊™◊® ◊ú◊™◊¢◊©◊ô◊ô◊î. ◊û◊¢◊ë◊ì◊ô Xeon ◊û◊î◊ì◊ï◊® ◊î◊©◊ô◊©◊ô ◊ï◊î◊û◊ê◊ô◊¶◊ô◊ù ◊î◊ô◊ô◊¢◊ï◊ì◊ô◊ô◊ù Gaudi 3 ◊û◊ê◊§◊©◊®◊ô◊ù ◊ú◊ê◊®◊í◊ï◊†◊ô◊ù ◊ú◊î◊ê◊ô◊• ◊ê◊™ ◊§◊ô◊™◊ï◊ó ◊ï◊î◊ò◊û◊¢◊™ ◊ô◊ô◊©◊ï◊û◊ô AI ◊ë◊ß◊†◊î ◊û◊ô◊ì◊î ◊í◊ì◊ï◊ú, ◊™◊ï◊ö ◊©◊û◊ô◊®◊î ◊¢◊ú ◊ô◊¢◊ô◊ú◊ï◊™ ◊í◊ë◊ï◊î◊î ◊ï◊™◊û◊ï◊®◊î ◊õ◊ú◊õ◊ú◊ô◊™ ◊ô◊ï◊¶◊ê◊™ ◊ì◊ï◊§◊ü. ◊ê◊ô◊†◊ò◊ú ◊û◊¶◊ô◊¢◊î ◊í◊ô◊©◊î ◊§◊™◊ï◊ó◊î ◊ï◊í◊û◊ô◊©◊î ◊î◊û◊ê◊§◊©◊®◊™ ◊©◊ô◊ú◊ï◊ë ◊ó◊ú◊ß ◊©◊ú ◊ó◊ï◊û◊®◊î ◊ï◊™◊ï◊õ◊†◊î ◊û◊û◊í◊ï◊ï◊ü ◊°◊§◊ß◊ô◊ù, ◊ï◊ë◊õ◊ö ◊†◊ï◊™◊†◊™ ◊ú◊ê◊®◊í◊ï◊†◊ô◊ù ◊ê◊™ ◊î◊õ◊ú◊ô◊ù ◊î◊ì◊®◊ï◊©◊ô◊ù ◊ú◊î◊ù ◊ú◊î◊ê◊¶◊™ ◊î◊©◊ô◊û◊ï◊© ◊ë- GenAI ◊ï◊ë◊û◊ï◊ì◊ú◊ô◊ù ◊í◊ì◊ï◊ú◊ô◊ù, ◊õ◊û◊ï ◊í◊ù ◊ú◊î◊ß◊ò◊†◊™ ◊î◊™◊ú◊ï◊™ ◊ë◊û◊¢◊®◊õ◊ï◊™ ◊ß◊†◊ô◊ô◊†◊ô◊ï◊™ ◊©◊ú ◊ô◊¶◊®◊†◊ô◊ù ◊ê◊ó◊®◊ô◊ù. ◊û◊®◊õ◊ñ◊ô ◊î◊§◊ô◊™◊ï◊ó ◊©◊ú ◊ê◊ô◊†◊ò◊ú ◊ë◊ô◊©◊®◊ê◊ú, ◊©◊û◊û◊ï◊ß◊û◊ô◊ù ◊ë◊ó◊ô◊§◊î, ◊§◊™◊ó ◊™◊ß◊ï◊ï◊î, ◊ô◊®◊ï◊©◊ú◊ô◊ù ◊ï◊ß◊®◊ô◊ô◊™ ◊í◊™, ◊û◊©◊ó◊ß◊ô◊ù ◊™◊§◊ß◊ô◊ì ◊û◊§◊™◊ó ◊ë◊¢◊ô◊¶◊ï◊ë ◊î◊ì◊ï◊® ◊î◊ë◊ê ◊©◊ú ◊ò◊õ◊†◊ï◊ú◊ï◊í◊ô◊ï◊™ ◊¢◊ô◊ë◊ï◊ì ◊ï-AI , ◊ï◊û◊û◊©◊ô◊õ◊ô◊ù ◊ú◊î◊†◊ô◊¢ ◊ê◊™ ◊î◊ó◊ì◊©◊†◊ï◊™ ◊î◊í◊ú◊ï◊ë◊ú◊ô◊™ ◊©◊ú ◊î◊ó◊ë◊®◊î ◊ë◊ê◊û◊¶◊¢◊ï◊™ ◊©◊ô◊ú◊ï◊ë ◊©◊ú ◊ë◊ô◊¶◊ï◊¢◊ô◊ù, ◊í◊û◊ô◊©◊ï◊™ ◊ï◊ó◊ì◊©◊†◊ï◊™ ◊û◊™◊û◊ì◊™.◊õ◊ê◊ü ◊ê◊§◊©◊® ◊ú◊ë◊ó◊ï◊® ◊™◊ó◊ï◊û◊ô ◊¢◊†◊ô◊ô◊ü, ◊ï◊ê◊†◊ó◊†◊ï ◊†◊™◊ê◊ô◊ù ◊ú◊ö ◊õ◊™◊ë◊ï◊™ ◊ë◊ê◊ï◊§◊ü ◊ê◊ô◊©◊ô. ◊î◊õ◊™◊ë◊ï◊™ ◊ô◊ï◊§◊ô◊¢◊ï ◊õ◊ê◊ü ◊ï◊ë◊®◊ó◊ë◊ô ◊î◊ê◊™◊®, ◊ï◊î◊°◊ô◊û◊ï◊ü ◊©◊ú◊†◊ï ◊ô◊î◊ô◊î ◊î◊†◊î ◊î◊õ◊™◊ë◊ï◊™ ◊©◊î◊™◊ê◊û◊†◊ï ◊ú◊ö ◊ê◊ô◊©◊ô◊™. ◊®◊ï◊¶◊î ◊ú◊®◊¢◊†◊ü ◊î◊¢◊ì◊§◊ï◊™? ◊ë◊ë◊ß◊©◊î, ◊ê◊†◊ó◊†◊ï ◊ú◊ê ◊©◊ï◊§◊ò◊ô◊ù ◊ñ◊î ◊î◊û◊ß◊ï◊ù ◊ú◊î◊õ◊ô◊® ◊ê◊™ ◊î◊ó◊ë◊®◊ï◊™, ◊î◊û◊©◊®◊ì◊ô◊ù ◊ï◊õ◊ú ◊û◊ô ◊©◊¢◊ï◊©◊î ◊ê◊™ ◊î◊î◊ô◊ô◊ò◊ß ◊ë◊ô◊©◊®◊ê◊ú (◊ï◊ô◊© ◊í◊ù ◊û◊ú◊ê ◊û◊©◊®◊ï◊™ ◊§◊™◊ï◊ó◊ï◊™!) #◊™◊ï◊õ◊ü ◊û◊ß◊ï◊ì◊ù◊î◊†◊ô◊ï◊ñ◊ú◊ò◊® ◊©◊ú◊†◊ï ◊¢◊ï◊©◊î ◊ê◊™ ◊î◊ê◊ß◊°◊ò◊®◊î ◊û◊ô◊ô◊ú ◊¢◊ù ◊î◊¢◊ì◊õ◊ï◊†◊ô◊ù ◊ï◊î◊ó◊ì◊©◊ï◊™ ◊©◊ú ◊î◊©◊ë◊ï◊¢¬© ◊õ◊ú ◊î◊ñ◊õ◊ï◊ô◊ï◊™ ◊©◊û◊ï◊®◊ï◊™ ◊ú◊í◊ô◊ß◊ò◊ô◊ô◊ù◊§◊ô◊™◊ï◊ó ◊ê◊™◊®◊ô◊ùdesigned by designed by¬†¬†| ◊§◊ô◊™◊ï◊ó ◊ê◊™◊®◊ô◊ù◊ë◊í◊ú◊ú ◊ñ◊î ◊ê◊†◊ó◊†◊ï ◊û◊ß◊§◊ô◊ì◊ô◊ù ◊©◊î◊ü ◊ú◊ê ◊ô◊¶◊ô◊ß◊ï, ◊ê◊ë◊ú ◊î◊ü ◊û◊ê◊§◊©◊®◊ï◊™ ◊ú◊†◊ï ◊ú◊™◊™ ◊ú◊õ◊ù ◊™◊ï◊õ◊ü ◊ë◊ó◊ô◊†◊ù.</p> <p>◊§◊®◊°◊ï◊û◊ï◊™ ◊¢◊ï◊ñ◊®◊ï◊™ ◊ú◊†◊ï ◊ú◊î◊™◊ß◊ô◊ô◊ù ◊ï◊ú◊î◊™◊û◊ß◊ì ◊ë◊û◊î ◊©◊ó◊©◊ï◊ë: ◊ú◊ô◊¶◊ï◊® ◊¢◊ë◊ï◊®◊ö ◊™◊ï◊õ◊ü ◊û◊ß◊¶◊ï◊¢◊ô ◊ï◊û◊¢◊†◊ô◊ô◊ü. ◊õ◊ì◊ô ◊ú◊î◊û◊©◊ô◊ö ◊ú◊ô◊î◊†◊ï◊™ ◊û◊í◊ô◊ß◊ò◊ô◊ô◊ù, ◊õ◊ì◊ê◊ô ◊ú◊î◊°◊ô◊® ◊ê◊™ ◊î◊ó◊°◊ô◊û◊î ◊û◊î◊ê◊™◊® ◊©◊ú◊†◊ï. ◊ê◊†◊ó◊†◊ï ◊û◊ë◊ò◊ô◊ó◊ô◊ù ◊ú◊ê ◊ú◊î◊¶◊ô◊£.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[◊û◊¢◊®◊õ◊ï◊™ RAG ◊ô◊õ◊ï◊ú◊ï◊™ ◊ú◊§◊™◊ï◊® ◊ê◊™ ◊™◊ï◊§◊¢◊™ ◊î◊î◊ñ◊ô◊ï◊™ ◊©◊ú LLMs, ◊ê◊ë◊ú ◊õ◊ì◊ô ◊ú◊ë◊†◊ï◊™ ◊ê◊ó◊™ ◊ò◊ï◊ë◊î ◊™◊¶◊ò◊®◊õ◊ï ◊ú◊ß◊ë◊ú ◊î◊®◊ë◊î ◊î◊ó◊ú◊ò◊ï◊™ ◊ß◊®◊ô◊ò◊ô◊ï◊™ (◊ï◊ú◊ß◊ï◊ï◊™ ◊©◊™◊í◊ô◊¢◊ï ◊î◊õ◊ô ◊ß◊®◊ï◊ë ◊ú◊û◊ï◊©◊ú◊ù)]]></summary></entry><entry><title type="html">Intel Labs Introduces RAG-FiT Open-Source Framework for Retrieval Augmented Generation in LLMs - Intel Community</title><link href="https://danielfleischer.github.io/blog/2024/intel-labs-introduces-rag-fit-open-source-framework-for-retrieval-augmented-generation-in-llms-intel-community/" rel="alternate" type="text/html" title="Intel Labs Introduces RAG-FiT Open-Source Framework for Retrieval Augmented Generation in LLMs - Intel Community"/><published>2024-10-09T00:00:00+00:00</published><updated>2024-10-09T00:00:00+00:00</updated><id>https://danielfleischer.github.io/blog/2024/intel-labs-introduces-rag-fit-open-source-framework-for-retrieval-augmented-generation-in-llms---intel-community</id><content type="html" xml:base="https://danielfleischer.github.io/blog/2024/intel-labs-introduces-rag-fit-open-source-framework-for-retrieval-augmented-generation-in-llms-intel-community/"><![CDATA[<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                        Success!  Subscription added.
                    
                   
                
                    
                        Success!  Subscription removed.
                    
                    
                
                    
                        Sorry, you must verify to complete this action. Please click the verification link in your email. You may re-send via your
                        profile.
                    
                Scott Bair is a key voice at Intel Labs, sharing insights into innovative research for inventing tomorrow‚Äôs technology.¬†Intel Labs researchers Daniel Fleischer, Moshe Berchansky, and Moshe Wasserblat collaborated on RAG-FiT.HighlightsIntel Labs introduces RAG-FiT, an open-source framework for augmenting large language models (LLMs) for retrieval-augmented generation (RAG) use cases. Available under an Apache 2.0 license, RAG-FiT integrates data creation, training, inference, and evaluation into a single workflow, assisting in the creation of data-augmented datasets for training and evaluating LLMs in RAG settings. This integration enables rapid prototyping and experimentation with various RAG techniques, allowing users to easily generate datasets and train RAG models using internal or specialized knowledge sources.The library assists in creating data to train models using parameter-efficient fine-tuning (PEFT), which allows users to finetune a subset of parameters in a model. The Python-based framework is designed to serve as an end-to-end experimentation environment, enabling users to quickly prototype and experiment with different RAG techniques, including data selection, aggregation and filtering, retrieval, text processing, document ranking, few-shot generation, prompt design using templates, fine-tuning, inference, and evaluation.To demonstrate the effectiveness of the RAG-FiT framework (formerly known as RAG Foundry), Intel Labs researchers augmented and fine-tuned Llama 3.0 and Phi-3 models with diverse RAG configurations, showcasing consistent improvements across three knowledge-intensive question-answering tasks.Using RAG Systems to Address LLM LimitationsDespite their impressive capabilities, LLMs have inherent limitations. These models can produce plausible sounding but incorrect or nonsensical answers, struggle with factual accuracy, lack access to up-to-date information after their training cutoff, and struggle in attending to relevant information in large contexts.RAG enhances LLMs performance by integrating external information using retrieval mechanisms. Retrieving specific data from knowledge bases outside the model can effectively address knowledge limitations, which in turn can reduce hallucinations, improve the relevance of generated content, provide interpretability and could be vastly more cost efficient. Furthermore, recent research indicates that fine-tuning LLMs for RAG can achieve state-of-the-art performance, surpassing that of larger proprietary models.How RAG-FiT WorksAs an experimentation environment for researchers, the backbone of the RAG-FiT library consists of four distinct modules: data creation, training, inference, and evaluation. Each module is encapsulated and controlled by a configuration file, ensuring compatibility between the output of one module and the input of the next file. This modular approach allows isolation and independent experimentation on each step, enabling the production of multiple outputs and the concurrent execution of numerous experiments. Evaluation can be conducted on the generated outputs as well as on any feature within the data, including retrieval, ranking, and reasoning.Figure 1. In the RAG-FiT framework, the data augmentation module saves RAG interactions into a dedicated dataset, which is then used for training, inference, and evaluation.Dataset creation: The processing module facilitates the creation of context-enhanced datasets by persisting RAG interactions, which are essential for RAG-oriented training and inference. These interactions encompass dataset loading, column normalization, data aggregation, information retrieval, template-based prompt creation, and various other forms of pre-processing. The processed data can be saved in a consistent, model-independent format, along with all associated metadata, ensuring compatibility and reproducibility across different models and experiments.The processing module supports the handling of multiple datasets at once through global dataset sharing. This feature allows each step of the pipeline to access any of the loaded datasets, enhancing flexibility and allowing for complex processing procedures. Furthermore, the module includes step caching, which caches each pipeline step locally. This improves compute efficiency, and facilitates easy reproduction of results.Training: Users can train any model on the augmented datasets. A training module is used to fine-tune models from the datasets created by the previous processing module. The training module relies on the well-established training framework, TRL, for transformer reinforcement learning. The module also supports advanced efficient training techniques, such as PEFT and low-rank adaptation (LoRA) to customize the LLM for specific use cases without retraining the entire model.Inference: The inference module can generate predictions using the augmented datasets with trained or untrained LLMs. Inference is conceptually separated from the evaluation step, since it is more computationally demanding than evaluation. Additionally, users can run multiple evaluations on a single prepared inference results file.Evaluation: Custom metrics can be easily implemented or users can run current metrics, including Exact Match (EM), F1 Score, ROUGE, BERTScore, DeepEval, Ragas, Hugging Face Evaluate, and classification. Users can run metrics locally on each example, or globally on the entire dataset, such as recall for classification-based metrics. In addition to input and output texts, metrics can utilize any feature in the dataset, such as retrieval results, reasoning, citations, and attributions. In addition, the evaluation module uses a processing step called an Answer Processor, which can implement custom logic and perform many tasks, including cleaning and aligning outputs.Performance of RAG-FiT Augmentation TechniquesTo illustrate the utility of the framework, Intel Labs researchers conducted experiments involving retrieval, fine-tuning, chain-of-thought (CoT) reasoning, and a negative distractor documents technique. The team compared Llama 3.0 and Phi-3, two widely accepted baseline models, using enhancement methods across TriviaQA, PubMedQA, and ASQA, three knowledge-intensive question-answering datasets. The TriviaQA and PubMedQA datasets contain relevant context, while for the ASQA dataset, retrieval was done over a Wikipedia corpus using a dense retriever.The team measured and reported EM for TriviaQA, STR-EM for ASQA, and accuracy and F1 Score for PubMedQA. In addition, researchers evaluated two Ragas metrics: faithfulness (the relation between the generated text and the context) and relevancy (the generated text and the query). Overall, the two models showed consistent improvements across the three knowledge-intensive question-answering tasks.Figure 2. Evaluation results of baseline and different RAG settings for the three datasets and two models tested. In bold are the best configurations per dataset, based on the main metrics.For TriviaQA, retrieved context improved the results, fine-tuning the RAG setting boosted the results, but fine-tuning on CoT reasoning (which includes training on a combination of gold passages and distractor passages) decreased performance. For this dataset, the best method is model dependent. For ASQA, every method improved upon the baseline, CoT reasoning produced consistent improvement in both models, as well as fine-tuning of the CoT configuration, which performed best. Finally, for PubMedQA, almost all methods improved upon the baseline (with one exception), CoT reasoning improved on the untrained RAG setting, but for fine-tuning, the RAG method performed best in both models.Finally, the faithfulness and relevancy scores often did not correlate with the main metrics, or with each other, possibly indicating they capture different aspects of the retrieval and generated results, and represent a trade-off in performance.The results demonstrate the usefulness of RAG techniques for improving performance, as well as the need to carefully evaluate different aspects of a RAG system on a diverse set of datasets.
					You must be a registered user to add a comment. If you've already registered, sign in. Otherwise, register and sign in.
				Community support is provided Monday to Friday. Other contact methods are available here.Intel does not verify all solutions, including but not limited to any file transfers that may appear in this community. Accordingly, Intel disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade.For more complete information about compiler optimizations, see our Optimization Notice.
</code></pre></div></div>]]></content><author><name></name></author><summary type="html"><![CDATA[Scott Bair is a key voice at Intel Labs , sharing insights into innovative research for inventing tomorrow‚Äôs technology. Intel Labs researchers]]></summary></entry><entry><title type="html">Open Domain Q&amp;amp;A using Dense Retrievers in fastRAG | by Daniel Fleischer | Medium</title><link href="https://danielfleischer.github.io/blog/2023/open-domain-qa-using-dense-retrievers-in-fastrag-by-daniel-fleischer-medium/" rel="alternate" type="text/html" title="Open Domain Q&amp;amp;A using Dense Retrievers in fastRAG | by Daniel Fleischer | Medium"/><published>2023-08-23T00:00:00+00:00</published><updated>2023-08-23T00:00:00+00:00</updated><id>https://danielfleischer.github.io/blog/2023/open-domain-qa-using-dense-retrievers-in-fastrag--by-daniel-fleischer--medium</id><content type="html" xml:base="https://danielfleischer.github.io/blog/2023/open-domain-qa-using-dense-retrievers-in-fastrag-by-daniel-fleischer-medium/"><![CDATA[<p>Sign upSign inSign upSign in‚Äì1ListenShareRetrieval augmented generation is an advanced technique in the field of natural language processing that combines the power of information retrieval and generative models. It aims to generate more informative and contextually appropriate responses to user queries by leveraging the retrieval of relevant passages or documents. This technique has significant potential in various applications, among them is Open Domain Question Answering; it is a field of research that focuses on developing systems capable of comprehending and answering a wide range of questions posed by users. It involves extracting relevant information from vast amounts of unstructured data using information retrieval techniques.Information retrieval used to rely on sparse techniques based on word statistics. In the traditional approach, documents were represented by a bag-of-words model, where the presence or absence of specific words determined the relevance of a document to a query. Score functions, like BM25 and TF-IDF, use word frequencies to score documents, balancing how frequently a keyword appears in a document versus how prevalent the word is in general. One popular DB is the Elasticsearch DB which uses the Lucene text search engine; it is based on word statistics and edit distance (a syntax method).With advancements in natural language processing and machine learning, information retrieval has shifted towards denser representations using embeddings. Embeddings capture the semantic meaning of words and phrases, allowing for a more nuanced understanding of the content; this enables more accurate matching of queries with relevant documents, as embeddings can capture subtle semantic similarities that traditional word statistics fail to capture. The shift from sparse to dense representations has significantly improved the performance and precision of retrieval systems. For an introduction to neural IR, see (Mitra and Craswell 2018); for a review of IR for Q&amp;A, see (Abbasiantaeb and Momtazi 2021).This blog serves as an introduction to dense retrieval and we focus on two dense document retrieval models: Dense Passage Retrieval (DPR, Karpukhin et al. 2020) and Contextualized Late Interaction over BERT (ColBERT, Khattab and Zaharia 2020). Both models use Semantic Search to find the relevant documents. Semantic search means we use a text‚Äôs dense representation to measure similarity between a given query and the potential relevant documents. The two models use different methods of storing the documents‚Äô vectors and measuring similarity between queries and documents. We will compare the models by measuring accuracy and latency on a known benchmark, called Natural Questions (NQ, Kwiatkowski et al. 2019), a collection of user submitted questions where answers can be found in Wikipedia articles.We would like to introduce fastRAG, a framework developed at Intel Labs and released as an open-source software recently. The goal of the framework is to enable rapid research and development of retrieval-augmented generative AI applications. These can be used for generative tasks such as question answering, summarization, dialogue systems, and content creation, while utilizing information-retrieval components to anchor LLM output using external knowledge.An application is represented by a pipeline, typically comprised of a knowledge-base (KB), retriever, ranker and a reader, typically an LLM, which ‚Äúreads‚Äù the query and retrieved documents, and generates an output. One can experiment with different architectures, models, benchmarking the results for performance and latency. Several of the models we offer are better suited for Intel hardware, achieving lower latency with comparable accuracy; on that in the next blog post.In the field of information retrieval, relatively recent updates promote the use of transformer encoder models as retrievals: documents in the knowledge-base are encoded as vectors and stored in an index. At runtime, the query is encoded as a vector and vector similarity search is used to find the most relevant documents. Similar process is used in re-ranking retrieved documents, where the encoding is done on-the-fly, specifically for the retrieved documents.Among the dense retrievals there are several approaches. One approach is to use a single token‚Äôs embeddings as a representative of the entire document. DPR (Karpukhin et al. 2020) is an example of that approach, where the encoders are trained to ‚Äúsummarize‚Äù the entire document in the first token‚Äôs embeddings. The method is a form of a bi-encoder, since it uses two encoders, one for the query and another for the documents; see illustration.Another approach is called Late Interaction, as defined first in ColBERT (Khattab and Zaharia 2020). The idea is to save (and index) the encoded vectors for all the words in the documents. At run-time the query vectors are compared with all the documents words‚Äô vectors (hence the ‚Äúlate‚Äù in late interaction) thus retrieving more relevant documents than DPR. Notice that indexing every token, instead of just the first token for each document, can increase the index size.Later refinements to this work, namely ColBERT v2 and PLAID (Santhanam, Khattab, Saad-Falcon, et al. 2022; Santhanam, Khattab, Potts, et al. 2022) helped reduce the index size and latency time thanks to two main improvements: first is quantization and compression of the vectors in the index. Secondly is a set of heuristics that cluster the vectors using the K-means algorithm, hierarchically choose the relevant documents‚Äô tokens for the query tokens based on the clusters‚Äô centroids. ColBERT v2 with PLAID index achieves state of the art retrieval performance with a low latency, close to the order of sparse retrieval (BM25, Lucene, Elasticsearch, etc.) but with much higher accuracy.The first step is creating a documents store of the type PLAIDDocumentStore. The store requires three paths: checkpoint, collection and an index.A ColBERT checkpoint is an encoder model, fine tuned for the task of retrieving. It‚Äôs based on a BERT architecture. One can download a trained checkpoint, for example here, trained by the paper authors. Encoders can be fine-tuned using these instructions: training. Next is the collection of documents which comprise the corpus. The collection should be a signle tsv file with columns: id, text, title (optional). Finally, the index is the vectors index created using the same checkpoint, encoding all tokens in the corpus, compressing and saving the result.We provide a script to create a PLAID vector index using a ColBERT encoder and a documents collection in here.Once we have all the ingredients, we initialize the document store:Next we define a retriever using the document store we just define:We define a pipeline; it has the following form:We can use the Haystack pipeline API to connect with external components. In this example the pipeline contains just the retriever:Running the queries through the pipeline is very easy:The results is a hash map with documents key containing a list of results: documents with relevancy scores.To test ColBERT, we will use the Natural Questions benchmark (Kwiatkowski et al. 2019). The external knowledge is a collection of Wikipedia passages.As a baseline, we‚Äôll use the original implementation of DPR, together with a checkpoint that was fine-tuned on Natural Questions, see download instructions. DPR model is released under the CC-BY-NC 4.0 license.DPR uses the Faiss vector search library (Johnson, Douze, and J√©gou 2019). We test two configurations for storing the vectors: flat and HNSW. Flat is slow but accurate, since an exhaustive similarity search is done. HNSW (Malkov and Yashunin 2018) is an approximate vector search method; the vectors are organized into a graph to enable faster than linear search. Building an optimal HNSW graph requires some parameter tuning; these control the trade-off between speed, accuracy and index size.For ColBERT, we use the ColBERTv2 checkpoint from here, which was fine-tuned on the MS MARCO (Bajaj et al. 2018) dataset, which comprised of Bing questions and answers based on web search results.We report recall and MRR values for k values of 5, 10, 20, 50, and 100. We also measure latency (at k=100) (ms/query), and report the vector index size in GBs, as there is a trade-off between performance and accuracy.Measurements done on an Intel AWS instance, with a Xeon processor. AWS instance type is r6i.16xlarge; 32 cores, 512GB RAM, Intel(R) Xeon(R) Platinum 8375C CPU @ 2.90GHz. Conda 23.1.0, python 3.9.16, AMI image ami-0f1a5f5ada0e7da53, Amazon Linux 2, version 5.10.177-158.645.amzn2.x86_64. The Wikipedia text collection size is 13GB.First, we note there is a difference in accuracy between the ColBERT model and DPR. The quality of the embeddings generated from a trained encoder is crucial for high quality retrieval. As the DPR encoders were fine-tuned on the Natural Questions dataset, this is probably one of the reasons explaining the difference.Next, we compare the two indexing methods for DPR: flat and HNSW. Flat index query takes 35x longer than HNSW, at almost 1.5 seconds per query. HNSW is faster, with only a small accuracy penalty; however, index size is bigger, at ~2.3x the size of the flat index.It is notable that although ColBERT encodes and stores all the documents tokens, thanks to its optimizations, the index size is comparable to a flat Faiss index, storing only the first token‚Äôs embedding for each document.One of the goals was to present the clear trade off between accuracy and performance, more specifically, between recall, latency and memory usage (the index size, as these are stored in-memory). To summarize, we introduced two dense retrieval algorithms, ColBERT with a PLAID index and DPR. We tested these on the open-domain Q&amp;A dataset Natural Questions, measuring accuracy and latency.Experience the capabilities of ColBERT in fastRAG through the following Notebook example. Familiarize yourself with fastRAG by exploring our user-friendly UI demos at Running Demos in fastRAG. Start using the ColBERT encoder, accessible from the HuggingFace hub. Easily create a document index, as detailed in our guide at Indexing in fastRAG. Furthermore, we offer full support for the DPR retriever; see example DPR configuration. Unleash the potential of fastRAG and revolutionize your workflow today!Tests done by Intel on March 14th, 2023.Performance varies by use, configuration and other factors. Learn more at www.Intel.com/PerformanceIndex.¬© Intel Corporation. Intel, the Intel logo, and other Intel marks are trademarks of Intel Corporation or its subsidiaries. Other names and brands may be claimed as the property of others.Abbasiantaeb, Zahra, and Saeedeh Momtazi. 2021. ‚ÄúText-Based Question Answering from Information Retrieval and Deep Neural Network Perspectives: A Survey.‚Äù Wires Data Mining and Knowledge Discovery 11 (6): e1412. https://doi.org/10.1002/widm.1412.Bajaj, Payal, Daniel Campos, Nick Craswell, Li Deng, Jianfeng Gao, Xiaodong Liu, Rangan Majumder, et al. 2018. ‚ÄúMS MARCO: A Human Generated MAchine Reading COmprehension Dataset.‚Äù October 31, 2018. https://doi.org/10.48550/arXiv.1611.09268.Johnson, Jeff, Matthijs Douze, and Herv√© J√©gou. 2019. ‚ÄúBillion-Scale Similarity Search with GPUs.‚Äù Ieee Transactions on Big Data 7 (3): 535‚Äì47. https://doi.org/10.1109/TBDATA.2019.2921572.Karpukhin, Vladimir, Barlas Oƒüuz, Sewon Min, Patrick Lewis, Ledell Wu, Sergey Edunov, Danqi Chen, and Wen-tau Yih. 2020. ‚ÄúDense Passage Retrieval for Open-Domain Question Answering.‚Äù September 30, 2020. https://doi.org/10.48550/arXiv.2004.04906.Khattab, Omar, and Matei Zaharia. 2020. ‚ÄúColBERT: Efficient and Effective Passage Search via Contextualized Late Interaction over BERT.‚Äù June 4, 2020. https://doi.org/10.48550/arXiv.2004.12832.Kwiatkowski, Tom, Jennimaria Palomaki, Olivia Redfield, Michael Collins, Ankur Parikh, Chris Alberti, Danielle Epstein, et al. 2019. ‚ÄúNatural Questions: A Benchmark for Question Answering Research.‚Äù Transactions of the Association for Computational Linguistics 7 (August): 453‚Äì66. https://doi.org/10.1162/tacl_a_00276.Malkov, Yu A., and D. A. Yashunin. 2018. ‚ÄúEfficient and Robust Approximate Nearest Neighbor Search Using Hierarchical Navigable Small World Graphs.‚Äù August 14, 2018. https://doi.org/10.48550/arXiv.1603.09320.Mitra, Bhaskar, and Nick Craswell. 2018. ‚ÄúAn Introduction to Neural Information Retrieval.‚Äù Foundations and Trends¬Æ in Information Retrieval 13 (1): 1‚Äì126. https://doi.org/10.1561/1500000061.Santhanam, Keshav, Omar Khattab, Christopher Potts, and Matei Zaharia. 2022. ‚ÄúPLAID: An Efficient Engine for Late Interaction Retrieval.‚Äù May 19, 2022. https://doi.org/10.48550/arXiv.2205.09707.Santhanam, Keshav, Omar Khattab, Jon Saad-Falcon, Christopher Potts, and Matei Zaharia. 2022. ‚ÄúColBERTv2: Effective and Efficient Retrieval via Lightweight Late Interaction.‚Äù July 10, 2022. https://doi.org/10.48550/arXiv.2112.01488.‚Äî-1Research scientist at Intel LabsHelpStatusAboutCareersPressBlogPrivacyRulesTermsText to speech</p>]]></content><author><name></name></author><summary type="html"><![CDATA[We introduce 2 dense retrieval algorithms, ColBERT with a PLAID index and DPR. We tested these on the open-domain Q&A dataset Natural Questions, measuring accuracy and latency.]]></summary></entry></feed>